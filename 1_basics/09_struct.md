# Бүтэц

Агуулахын бүртгэлд зориулсан програм бичиж байна гэж бодоё. Агуулах нь төрөл бүрийн бараатай хайрцагаар дүүрсэн. Хайрцаг бүрийн хувьд дараах зүйлсийг бүртгэх хэрэгтэй:

* Агуулж байгаа барааны нэр
* Тоо ширхэг
* Үнэ

Эндээс нэг хайрцагийн тухай мэдээллийг програмд хэрхэн хадгалах вэ гэсэн асуулт гарна. Барааны нэр, тоо ширхэг, үнэ зэрэг өөр өөр төрөлтэй мэдээллүүдийг “нэг багц” болгон бүртгэх хэрэгтэй байна. Энэ тохиолдолд шинэ төрөл үүсгэж ашиглах нь тохиромжтой юм.

`struct` түлхүүр үг нь шинэ, нийлмэл өгөгдлийн төрөл үүсгэхэд ашиглагдана. Мөн өөрөөр _бүтэц төрөл_ гэж нэрлэдэг. Нийлмэл төрөл дотор бичигдсэн гишүүн хувьсагчийг _талбар_ гэнэ.

Жишээлбэл:

```go
type Box struct {
  name    string        /* барааны нэр */
  quantity    int        /* тоо ширхэг */
  cost    float64        /* нэг бүрийн үнэ */
}
```

`type` түлхүүр үг нь шинэ төрөл үүсгэж байгааг илэрхийлнэ. Түүний араас төрлийн нэр, тэгээд `struct` түлхүүр үгийг залгаж бичнэ.

## Шинэ обект үүсгэх

Шинэ төрлөөс обект үүсгэх хэд хэдэн арга зам бий:

```go
var b Box
```

Эсвэл дараах байдлаар үүсгэж болно:

```go
b := new(Box)
```

Бусад энгийн төрөлтэй адилаар `Box` төрлийн талбарууд нь (гишүүд) өөрсдийн төрлөөс хамааран `null` эсвэл `0` утгатай үүснэ. Үүнийг өөрчилж тодорхой утгууд заахыг хүсвэл дараах байдлаар бичнэ:

```go
b := Box { name: "Алим", quantity: 100, cost: 500.0 }
```

Эсвэл товчлоод талбарын нэрсийг орхиж бичиж болно:

```go
b := Box {"Алим", 100, 500.0}
```

## Талбарт хандах

Нийлмэл төрлийн талбарт хандахдаа цэг `.` үйлдлийг ашиглана:

```go
b.quantity = 10
b.cost = 510

fmt.Println(b.name, b.quantity, b.cost)
```

## Метод

Хайрцагийн нийт өртөгийг тооцоолох функцийг дараах байдалтай бичиж болно:

```go
func boxPrice(b Box) float64 {
    return b.quantity * b.cost
}
```

Эсвэл `boxPrice()` функцийг мөн бүтцийн гишүүн болгон өөрчилж болно. Ийм функцийг _метод_ гэж нэрлэнэ.

Методын бичиглэл нь ердийн функцээс бага зэрэг ялгаатай. Функцийн нэрний өмнө харъяалах обектыг заах хэрэгтэй. Энэ обектыг _хүлээн авагч_ гэж нэрлэнэ. Дараах жишээнд `b`  нь хүлээн авагч юм.

```go
func (b *Box) price() float64 {
    return b.quantity * b.cost
}
```

Ингээд методыг дуудахдаа талбартай адилаар цэг `.` үйлдэл хэрэглэнэ:

```go
fmt.Println(b.price())
```

Анхны `boxPrice()` функцийн нэрийг товчлоод `price()` болгосон. Учир нь энэ функц одоо `Box` төрөлд хамаатай болсон учраас “box” угтвар шаардлагагүй болж байна. Метод ашиглах нь нэр товчлохоос гадна кодыг илүү ойлгомжтой болгож өгдөг.


# Төрөл өртгөтгөх

Бүтцийн талбарууд нь ихэвчлэн ”юмтай байх”, “агуулагдах”, “харяалагдах” хамаарлыг илэрхийлдэг. Жишээлбэл дараах `Person` төрөл `Name` талбартай байна. Эндээс “хүн бол нэртэй” гэсэн хамаарал харагдаж байна.

```go
type Person struct {
    Name string
}
```

Харин методууд нь тухайн төрлийн “чадвар”, “зан байдлыг” илэрхийлдэг. Жишээлбэл `Person` төрөлд `Talk()` функц нэмэе. Эндээс “хүн ярьж чаддаг” гэсэн чадвар харагдах болно.

```go
type Person struct {

    func (p *Person) Talk() {
        fmt.Println("Сайна уу, Миний нэр ", p.Name)
    }
}
```

Дээрх төрлийг өргөтгөж `Android` нэртэй шинэ төрөл үүсгэе. Ингэхдээ шинэ `Android` төрөл нь `Person`-д байгаа бүх шинжийг авахыг хүсвэл яах вэ?  Үүнийг “Android бол Person” хэлбэрийн хамаарал гэж хэлж болно, ө.х `Person`-д байдаг шинжүүд (талбарууд) болон чадваруудыг (метод) бүгдийг нь `Android` агуулна гэсэн үг.

Ийм маягийн хамаарлыг бусад програмчлалын хэлэнд удамших, өвлөх, өргөтгөх гэх мэтээр нэрлэдэг. Go хэлэнд _эмбеддэд төрөл_ гэж нэрлэдэг бөгөөд дараах байдлаар бичдэг:

```go
type Android struct {
    Person     // embedding буюу Person төрлийн шинжийг агуулна

    model string // шинэ гишүүн
}
```

Энд `Person` төрлийн урд обект байхгүй бичигдсэнийг анзаараарай. Энэ тодорхойлолт нь шинээр үүсэж байгаа `Android` төрөл нь `Person` төрлийн бүх шинж, чадварыг агуулна гэдгийг илэрхийлнэ.

Ингээд хэрэв `Android` бол `Person` гэдэг нь үнэн бол `Android` төрлийн обект мөн “ярьж чадах” ёстой:

```go
a := new(Android)
a.Talk()
```

`Android` төрөлд `model` нэртэй нэг шинэ талбар нэмэгдсэн байгааг анзаараарай. Эндээс “Android бол Person” гэдэг нь үнэн, харин `Person` нь `Android`-оос өөр болж байна.
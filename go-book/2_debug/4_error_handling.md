# Алдааг боловсруулах

Алдааг Go хэлэнд ихэвчлэн функцийн буцах утгаар мэдээлдэг. Тиймээс функцээс буцааж байгаа утгатай хамт алдааны утгыг байнга шалгаж байх хэрэгтэй.

```go
if value, err := pack1.Func1(param1); err != nil {
  fmt.Printf(“Алдаа %s”, err.Error())
  return err
}
// алдаагүй бол value-г ашиглан дараагийн үйлдлийг гүйцэтгэнэ
```

Алдааг `error` интерфэйс төрлөөр тодорхойлдог. Энэ нь ямар нэг хэвийн бус төлөв үүссэн болохыг илэрхийлнэ. Алдааны утга `nil` бол алдаа гараагүй гэж үзнэ.

Алдаа боловсруулалтад анхаарах хэдэн зүйл бий:

* функцээс буцаасан алдааны кодыг байнга шалгах
* алдааг хэрэглэгчид мэдээлэх
* алдааг бичиж тэмдэглэж авах \(лог файлд, өгөгдлийн санд\)

Go хэлэнд try/catch механизм байхгүй. Харин defer, panic, recover зэрэг алдаа боловсруулах боломжууд бий. `defer`, `panic`, `recover` заавруудыг хослуулан хэрэглэж try/catch механизмтай ижил үр дүнд хүрэх боломжтой.

## Defer

`defer` заавар нь функцийн дуудалтыг стект бүртгэнэ, ингээд  функцийн ажиллагаа дуусахад төгсгөлд `defer`-т сануулсан функц, кодыг ажиллуулдаг. Функц алдаатай эсвэл хэвийн дууссан аль ч тохиолдолд `defer`-д бүртгүүлсэн дуудалт заавал ажилладаг. Тиймээс `defer` нь төгсгөлийн “цэвэрлэгээний” ажилд ихэвчлэн хэрэглэгддэг.

Жишээлбэл файл нээсэн бол заавал хаах хэрэгтэй байдаг. Хаах үйлдлийг функцийн эхэнд `defer` заавраар сануулаад орхиж болно. Функц дуусахад файл хаах үйлдлийг заавал гүйцэтгэх болно.

```go
func FileProcessing() {
  file, err := os.Open( “file.txt” )

  defer file.Close() // сануулж орхих, энэ код төгсгөлд нь ажиллана

  // … бусад үйлдэл
}
```

## Panic

Функц дотор `panic()` дуудвал ажиллагаа нь зогсож дээд функц рүү удирдлага шилжинэ. Хэрэв өмнө нь `defer` дуудалт байсан бол удирдлага шилжихээс өмнө түүнийг ажиллуулна. Энэ процесс дээш үргэлжлэн шилжсээр `main` функц дээр очиж програмын ажиллагааг таслан дэлгэцэнд алдааны мэдээлэл хэвлэж дуусдаг.

```go
var user = os.Getenv(“USER”)
func check() {
  if user == “” {
     panic(“$USER өгөгдөл олдсонгүй”)
  }
}
```

`regexp.MustCompile`,  `template.Must` гэх мэт стандарт сангийн олон функц panic үүсгэдэг. Мэдээж panic үүсгэж програмыг таслах нь хүсэхээр зүйл биш юм. Тиймээс аль болох ийм нөхцөл үүсэхээс зайлсхийж хамгаалах шалгалтуудыг хийх ёстой.

## Recover

`panic`-н гинжин дуудалтыг зогсооход `recover` зааврыг ашиглаж болно. `recover` нь panic-д орсон цуваа дуудалтыг зогсоон удирдлагыг авч функцийн ажиллагааг хэвийн үргэлжлүүлэх боломжийг олгоно.

`recover` зааврыг `defer` хийсэн функц дотор ашиглах хэрэгтэй. Ингэснээр функцийн төгсгөлд алдааг барьж цааш дамжуулалгүй шийдэх боломжтой болно.

Тэгэхээр `panic`-н тодорхойлолтыг бага зэрэг засвал: `panic` нь програмын ажиллагааг зогстол эсвэл замд нь `recover` заавар таарах хүртэл үргэлжлэн дамждаг гэж тодорхойлж болно.

Дараах жишээнд параметр болгон дамжуулсан `g` функцээс үүсэж болох алдааг `defer` дотор `recover` заавраар хамгаалсан байна.

```go
func protect(g func()) {
 defer func() {
   // panic-г барьж мэдээлэх
   if err := recover(); err != nil {
    log.Printf(“panic мэдээлэл: %v”, err)
   }
 }()

 log.Println(“эхлэл”)

 g()
 // рантайм алдаа гарч болзошгүй хэсэг
}
```

Бүх алдааг `recover` заавраар таслаж барих нь буруу байдаг. Ямар нөхцөлд ямар алдааг цааш дамжуулалгүй зогсоох ёстой вэ гэдэг дээр бодох хэрэгтэй. Ерөнхийдөө дараах тохиолдлуудад recover хийх нь зохимжтой:

* сэргээлт хийх
* цэвэрлэгээ хийх
* таслах ёсгүй код

Тухайлбал вэб сервер олон хүсэлттэй зэрэг ажиллаж байдаг. Нэг хүсэлтийг боловсруулах явцад тасалдал үүсэхэд вэб сервер тэр чигээрээ унаж болохгүй. Энэ тохиолдолд `recover` ашиглах нь зөв байна.

Харин зөвхөн лог бичиж авах эсвэл “харанхуйгаар” алдааг таслах нь буруу. Зөвхөн товлосон алдаагаа л барих хэрэгтэй, бусад алдааны хувьд цааш дамжих боломжийг нь олгох хэрэгтэй. Алдааг барьж хорих, таслахаас илүүтэй цааш дамжуулах тал дээр илүү “ардчилсан” байх хэрэгтэй. Ийм програм нь илүү эрүүл програм байдаг.

Java, .NET дээр програм бичдэг хөгжүүлэгчид `try/catch` блокыг маш их ашигладаг. Гэхдээ ихэнхидээ зориулалтын бусаар ашигладаг. Зарим кодон дотор `catch` блок нь хоосон эсвэл зүгээр л дэлгэцэнд мэдээлэл хэвлэх зорилготой бичигдсэн байдаг.

Хэрэв алдааг харанхуйгаар таслан зогсоогоод байвал програм гаднаа хэвийн ажиллаж байгаа мэт харагдавч дотроо олон алдаа баагтай, цаашлаад дебааг хийхэд маш хэцүү “дүлий” програм болдог.


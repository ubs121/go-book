# Өгөгдлийн бүтцүүд

Энэ бүлэгт олон элементийг агуулдаг массив, жагсаалт, мод, майп зэрэг өгөгдлийн бүтцийг судлана.

Өгөгдлийн бүтцүүд нь бүгд өөрийн онцлогтой. Жишээ нь массив нь хялбар, элементэд хандахад хурдан байдаг бол жагсаалт нь өөрчлөлтөд тохиромжтой, мод нь өгөгдөл хайх, эрэмбэлэх зэрэгт өргөн ашиглагддаг.


## Массив \(slice\)

Массив бол ижил төрлийн, тодорхой урттай, дугаарлагдсан өгөгдлийн дараалал юм. Санах ойд энэ бүтэц нь үргэлжилсэн хайрцгууд болж байрладаг. Нэг хайрцгийг нь элемент гэж нэрлэнэ. Элементийн тоог массивын хэмжээ эсвэл урт гэнэ.

Массив зарлалт нь дараах байдалтай:

```go
/* бүхэл тоон массив */
var arr []int
```

эсвэл

```go
arr:=[3]int{1, 2, 3}
```

Дээрх жишээнд 3 элемент бүхий `arr` массив үүсгэсэн байна. Массивын нэг элементэд хандахад массивын нэрний ард тухайн элементийн дугаарыг дөрвөлжин хаалтад `[ ]` бичиж заана. Массивын дугаарлалтыг `0`-ээс эхэлдэг. Тиймээс дээрх гурван элемент `arr[0]`, `arr[1]`, `arr[2]` гэж дугаарлагдана, мөн тусдаа хувьсагчид гэж төсөөлж болно.

Дараах жишээнд массивт байгаа 5 тооны дунджийг олсон байна.

```go
package main
import "fmt"

func main() {
    arr:=[]float32{ 34.0, 27.0, 45.0, 82.0, 22.0 }

    total:= arr[0] + arr[1] + arr[2] + arr[3] + arr[4]
    average:=  total / 5.0
    fmt.Printf("Нийт %f Дундаж %f\n", total, average)
}
```
Програмын гаралт:

```sh
Нийт 210.000000 Дундаж 42.000000
```

Урт массивын хувьд элемент бүрийг тоочиж бичих боломжгүй учраас давталт ашиглах нь тохиромжтой. Жишээлбэл массивын элементүүдийн нийлбэрийг бодоход `for` зааврыг ашиглаж болно. Массивын уртыг `len()` функцээр тодорхойлно.

```go
sum:=0
for i:=0; i<len(arr); i++ {
  sum += arr[i]
}
```

### make ба хувьсах урттай массив

`make` функцийг ашиглан шинэ массив үүсгэж болно, ингэхдээ хэмжээг нь мөн тодорхойлж болно. Жишээ нь 5 байтын массив үүсгэх бол дараах байдлаар дуудна:

```go
s := make([]byte, 5)
```


### Олон хэмжээст массив

Тогтмол урттай, хоёр хэмжээст массивыг дараах байдлаар үүсгэж болно:

```go
var matrix [3][3]float64
```

Хоёр хэмжээст массивын элементэд хандахын тулд дараах тэмдэглэгээг ашиглана:

```go
matrix[1][2] = 10
```

Элементүүдээр гүйхийн тулд хоёр давхар `for` заавар ашиглана:

```go
for y := 0; y < 3; y++ {
  for x := 0; x < 3; x++ {
    matrix[x][y] = 0
  }
}
```

Олон хэмжээст массивын хэмжээ тодорхойгүй \(ажиллах явцад тодорхой болох\) бол `make` ашиглан үүсгэж болно. Жишээ нь `n x m` хэмжээтэй массив үүсгэе. Энд `m` буюу хоёр дахь хэмжээс нь динамик байж болно.

```go
a:= make([]int, n) // эхний хэмжээс нь 'n'
for i:=0; i<n; i++ {
  a[i] = a([]int, m) // хоёр дахь хэмжээс нь 'm'
}
```
Элементэд `a[i][j]` гэж хандаж болно, энд 0 &le; i < n ба 0 &le; j < m байна.

## Функцэд массив дамжуулах

Функцэд хувьсагч дамжуулахад түүний утга нь функцийн стек мужид хуулагддаг тухай бид өмнө үзсэн. Тэгэхлээр том хэмжээтэй массивыг функцэд дамжуулвал их хэмжээний санах ой “иддэг” гэсэн үг юм. Үүнийг шийдэхийн тулд нэг бол массивыг таслаж \(слайс\) дамжуулах эсвэл заагч ашиглаж болно.

Заагчаар дамжуулах:

```go
array := [5]float64{7.0, 8.5, 9.1, 1.1, 3.4}
result := Sum(&array) // хаягийг дамжуулж байна
```

`Sum()` функцэд массивын хаягийг дамжуулж байна, ө.х бүтэн массивыг хуулах шаардлагагүй, зөвхөн массив байрлаж байгаа хаягийг дамжуулж байна гэсэн үг. Тийм учраас дахин дахин хуулалт явагдахгүй, санах ойд хэмнэлттэй.

Слайс дамжуулах: 

Слайс нь массивын тодорхой нэг үргэлжилсэн хэсгийг заадаг заагч юм. Үргэжилсэн хэсэг нь массив бүхэлдээ эсвэл түүний дэд хэсэг байж болно.

```go
result := Sum(array[:]) // бүтэн слайс дамжуулж байна
result := Sum(array[:2]) // слайс дамжуулж байна (0,1 элементүүд )
result := Sum(array[2:]) // слайс дамжуулж байна (2,3,4 элементүүд )
```

## Слайс үйлдлүүд

Слайс нь цаад зааж байгаа массивын хэмжээнд тултал сунаж болно. Жишээлбэл хэмжээг 1-ээр нэмэгдүүлэх бол дараах зааврыг бичиж болно:

```go
sl = sl[0:len(sl)+1]
```

Хэрэв цаад массивын хэмжээнээс давсан том хэмжээтэй слайс хэрэгтэй бол шинэ массив үүсгэх хэрэгтэй. Илүү том хэмжээтэй шинэ массив үүсгээд хуучныгаа шинэ том массив уруу хуулах хэрэгтэй.

```go
sl_from := []int{1,2,3}
sl_to := make([]int,10)
n := copy(sl_to, sl_from)
```

Үүнийг мөн өөрөөр `append()` функцээр гүйцэтгэж болно.

```go
sl3 := []int{1,2,3}
sl3 = append(sl3, 4, 5, 6)
```

Дараах хүснэгтэд слайс дээр хийдэг түгээмэл үйлдлүүдийг харуулсан байна.

| Үйлдэл | Хэрэгжүүлэх |
| --- | --- |
| Хоёр слайс залгах | `a=append(a, b...)` |
| Слайс хуулах | `b = make([]T, len(a)); copy(b, a)` |
| Өгөгдсөн i байрлал дахь элементийг хасах | `a = append(a[:i], a[i+1:]...)` |
| Дэд хэсгийг хасах | `a = append(a[:i], a[j:]...)` |
| Элемент өгөгдсөн байрлалд x элементийг оруулах | `a = append(a[:i], append([]T{x}, a[i:]...)...)` |
| Оройн элементийг авах | `x, a = a[len(a)-1], a[:len(a)-1]` |
| Оройд элемент нэмэх | `a = append(a, x)` |



## Жагсаалт

Жагсаалт нь нэг нь нөгөөгийн араас залгагдсан обектуудын гинжин цуваа юм. Go хэлний `container/list` пакет нь давхар холбоост жагсаалт төрлийг агуулдаг. Давхар холбоост жагсаалтын нэг элемент нь өмнөх болон арын элементээ заасан холбоостой байдаг.

Жагсаалтад элемент нэмэх, түүний элементүүдээр хэрхэн гүйхийг дараах програмд харуулав:

```go
package main

import (
  "fmt"
  "container/list"
)

func main() {
    var x list.List
    x.PushBack(1)
    x.PushBack(2)
    x.PushBack(3)

    for e := x.Front(); e != nil; e=e.Next() {
        fmt.Println(e.Value.(int))
    }
}
```

Энд харуулснаар `PushBack()` функцийг ашиглан 1, 2, 3 тоон утгуудыг жагсаалтад нэмж байна. Дараа нь жагсаалтын элементүүдээр давтаж байна, ингэхдээ эхний элементийг `Front()` функцээр олоод түүнээс цааш `Next()` функцээр дараа дараагийн элементүүдийг олж байна. Энэ давталтыг `nil` утга  буюу жагсаалтын төгсгөл хүртэл гүйцэтгэнэ.

## Стек

Стек нь “эхэлж орсон нь эхэлж гарах” зарчим дээр тулгуурласан жагсаалт төрлийн өгөгдлийн бүтэц юм. Стек бүтэц дээр дараах хоёр үйлдэл хийгдэнэ:

* Push – стекийн орой дээр элемент нэмэх
* Pop – стекийн оройноос элемент сугалах

Дараах жишээнд тоон стек хэрхэн үүсгэж, ашиглахыг харуулав.

```go
package main
import "fmt"

type IntStack struct {
	elems []int
}

// стекийн урт
func (s *IntStack) Len() int {
	return len(s.elems)
}

// стекийн оройд элемент нэмэх
func (s *IntStack) Push(value int) {
	s.elems = append(s.elems, value)
}

// стекийн оройгоос элемент авах
func (s *IntStack) Pop() int {
	if len(s.elems) == 0 {
		panic("stack is empty")
	}

	top := len(s.elems) - 1
	value := s.elems[top]
	s.elems = s.elems[:top]
	return value
}

func main() {
	stack := new(IntStack)

	stack.Push(1)
	stack.Push(2)
	stack.Push(3)

	for stack.Len() > 0 {
		fmt.Printf("%d ", stack.Pop())
	}
}
```
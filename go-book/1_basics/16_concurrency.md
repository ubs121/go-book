# Зэрэгцээ боловсруулалт

Зэрэгцээ боловсруулалт гэдэг нь нэг зорилготой олон ажлыг зэрэг амжуулах тухай юм. Ихэвчлэн том хэмжээний ажлыг жижиг хэсгүүдэд хэрхэн хуваах, ямар хэсгүүд нь зэрэг хийгдэх боломжтой, зэрэг ажиллахдаа хэсгүүд хоорондоо хэрхэн мэдээ солилцох зэргийг тооцож зохиомж хийнэ гэсэн үг. Зэрэгцээ боловсруулалтын ойрхон жишээ гэвэл бид компютерийн хулгана, гар, дэлгэцийг зэрэг ашигладаг. Хэрэв эдгээр төхөөрөмжүүд дараалж ажилладаг байсан бол хэчнээн болхи, үр ашиггүй байхыг та төсөөлж байгаа бизээ.

Дан процессор дээр ч зэрэгцээ боловсруулалтын тухай ярих боломжтой. Нэгэнт дан процессор дээр зэрэг гүйцэтгэж чадаж байвал олон процессор дээр бүр илүү үр дүнтэй байна. Энэ бол зэрэгцээ боловсруулалтын үндсэн санаа юм. 

Нэг процессор дээр сайн ажиллаж байсан програм 4 процессор дээр удаан ажиллах тохиолдол байдаг. Энэ бол зохиомж муу байгаагийн илрэл юм. Ө.х зэрэгцээ ажиллуулах талаар бодоогүй хийгдсэн програм байна гэсэн үг. Ийм програмын хувьд механикаар процессор, цөмийн тоог нэмээд ч олигтой үр дүнд хүрэхгүй.

Жишээ болгон хуучин хог шатаах ажлыг хэрхэн зэрэг, хурдан амжуулах хувилбаруудыг харая.

![](res/gophersimple1.jpg)

Зөвхөн 1 зурам ажиллавал  хэт удаан байх болно.

![](res/gophersimple1_1.jpg)

2 зурам ажиллавал нэмэлт тэрэг хэрэгтэй болно.

![](res/gophersimple2.jpg)

2 зурам 2 тэрэгтэй бол илүү хурдан дуусгана. Гэхдээ шатаах зуухан дээр очоод ээлжлэх хэрэгтэй болно. Зурамнууд хоорондоо ойлголцох хэрэгтэй болно, хүлээлт үүснэ.

![](res/gophercomplex0.jpg)

3 зурам ажиллаж болно. Гэхдээ зохицуулалт хийхгүй бол дундах зурам хоёр талд ээлжлэн хүлээх хэрэгтэй болно.

![](res/gophercomplex1.jpg)

4 зурам ажиллаад зөв зохицуулалт хийвэл анхны хувилбараас 4 дахин хурдан дуусгах болно.

Эндээс дүгнэхэд ажлыг маш олон аргаар хувааж, зохиомжилж болж байна. Зөвхөн механикаар зурмын тоог нэмээд хурдан болохгүй, зөв зохицуулалт, ажлын зөв хуваалт, хувиарлалт чухал болох нь харагдаж байна. Энэ бол зэрэгцээ боловсруулалтын зохиомж юм.

Нэгэнт оновчтой зохиомж гарсан бол үүнийг параллел болгоход маш хялбар байх болно. Тухайлбал хоёр шатаах зуух байсан бол анхны зохиомжийг өргөтгөөд ажлын параллел хоёр групп зохион байгуулж болно.

![](res/gophercomplex2.jpg)

Эндээс үзэхэд ажлыг зэрэг гүйцэтгэх, хамгийн бага хугацаанд гүйцэтгэх тухай бодох нь хөгжүүлэгчийн ур чадвараас ихээхэн хамааралтай болох нь ойлгогдоно.

Гэхдээ зэрэгцээ боловсруулалтад мөрддөг ерөнхий дүрмүүд бий.

* Жижиг хэсэг бүр 100μs -с 1ms хооронд тооцоолж дуусах боломжтой байх. Хэрэв хэт жижиг ажлууд бол процесс үүсгэх, ачаалах, цэвэрлэх гэх мэт "удирдлагын" шинжтэй үйлдлүүд ихсэх болно. Хэрэв хэт том бол зөвхөн нэг ажлыг дуусгахын тулд удаан хүлээлт үүсгэх болно. Энэ нь зэрэг боловсруулахын давуу талыг үгүй болгоно.

* Үл хамаарах хэсгүүдийн хооронд ашиглах дундын өгөгдлийг маш бага байлгах. Ялангуяа дундын санах ойн муж руу бичих үйлдэл нь удаашруулах, түгжээ үүсгэх гэх мэт асуудалтай байдаг. Харин унших үйлдэл нь асуудал багатай байдаг.

* Өгөгдлийг аль болох далдлах, локал ашиглах. Локал буюу кээшэд байгаа өгөгдөл нь унших, бичихэд илүү хурдан байдаг.

Сайн хэл, багаж байхаас гадна програмын дотоод зохиомж хамгийн чухал хэсэг нь байдаг. Бид програмын зохиомжоо хийх үедээ зэрэг “амжуулж” болох хэсгүүдийг олж харж чаддаг, тэдгээрийн холбоосыг сайн зохиомжилж чаддаг байх хэрэгтэй.

Зэрэгцээ програмчлалыг сайн ойлгохын тулд бодит ертөнц дээрх процессуудыг сайн ажиглах хэрэгтэй. Жишээ нь зам дээр явж байгаа машинуудыг харж болно. Машинууд бие биенээс үл хамааран урагшлах нь зэрэгцээ өрнөж байгаа процесс, гэхдээ тэд осол аваар гаргахгүйн тулд хоорондоо мессеж солилцож \(баруун зүүн дохио өгөх\) ойлголцох шаардлагатай болдог.

#  Go функц (goroutine)

Go функц гэдэг нь бусад функцтэй зэрэг ажиллах функц юм. Go функц үүсгэхийн тулд функцийн нэрний өмнө `go` түлхүүр үгийг тавьж дуудах хэрэгтэй:

```go
package main
import "fmt"

func f(n int) {
    for i := 0; i < 10; i++ {
        fmt.Println(n, ":", i)
    }
}

func main() {
    go f(0)
    var input string
    fmt.Scanln(&input)
}
```

Дээрх програм нь хоёр функцээс тогтоно. Эхнийх нь `main()` функц өөрөө байна, хоёр дахь нь `go f(0)` гэсэн дуудалтаар үүснэ. Ердийн үед функц дуудахад тухайн функц дотор бичигдсэн бүх заавар ажиллаж дууссаны дараа дараагийн мөрд програмын удирдлага шилждэг. Go функцийн тохиолдолд програмын удирдлага шууд дараагийн мөрд шилжинэ, ө.х Go функц дотор бичигдсэн зааврууд ажиллаж дуусахыг хүлээхгүй гэсэн үг. Үүнийг нотлон харуулах зорилгоор `fmt.Scanln()` функцийг дуудсан байгаа. Энэ функц нь гараас мэдээлэл оруулахыг хүлээнэ, хэрэв ингэж хүлээхгүй бол програмын ажиллагаа шууд тасарч `f()` функц тоонуудыг хэвлэж амжихгүй тасрах болно.

Go функц нь маш хөнгөн байдаг бөгөөд олон тоогоор үүсгэх боломжтой байдаг. Жишээлбэл 10 ширхэг go функцийг дараах байдлаар үүсгэж болно:

```go
func main() {
    for i := 0; i < 10; i++ {
        go f(i)
    }
    var input string
    fmt.Scanln(&input)
}
```

Дээрх програмыг ажиллуулахад go функцүүд дарааллаар ажиллаад байгаа мэт харагдаж байгааг ажиглаарай. Ө.х тоонууд дэс дарааллын дагуу хэвлэгдэж байна. Үнэндээ go функцүүдыг дуудсан дарааллаар маш хурдан ажиллаж дуусаад байгаа учраас тэгж харагдаж байгаа юм. Зэрэг ажиллаж байгааг нотлохын тулд тоо хэвлэлтүүдийн хооронд бага зэрэг хүлээлт оруулая. Үүнд `time.Sleep` ба `rand.Intn` функцүүдийг хослуулан ашиглаж болно:

```go
package main

import (
  "fmt"
  "time"
  "math/rand"
)

func f(n int) {
    for i := 0; i < 10; i++ {
        fmt.Println(n, ":", i)
        amt := time.Duration(rand.Intn(250))
        time.Sleep(time.Millisecond * amt)
    }
}

func main() {
    for i := 0; i < 10; i++ {
        go f(i)
    }
    var input string
    fmt.Scanln(&input)
}
```

Өөрчлөлтийн үр дүнд `f()` функц бүр 0 – 10 хүртэлх тоог 0 - 250 миллисекундын завсарлагатайгаар хэвлэнэ. Завсарлага оруулснаар бусад функцүүд зэрэг ажиллаж ижил үйлдлийг хийж байгаа гэдгийг харах боломжтой болсон байна.

# Суваг

Зэрэгцээ ажиллаж байгаа хоёр go функц хоорондоо мэдээлэл солилцохдоо _суваг_ ашиглана. Дараах програмд суваг ашигласан байна:

```go
package main
import (
  "fmt"
  "time"
)

func pinger(c chan string) {
    for i := 0; ; i++ {
        c <- "ping"
    }
}

func printer(c chan string) {
    for {
        msg := <- c
        fmt.Println(msg)
        time.Sleep(time.Second * 1)
    }
}

func main() {
    var c chan string = make(chan string)

    go pinger(c)
    go printer(c)

    var input string
    fmt.Scanln(&input) // Enter дарахыг хүлээх
}
```

Энэ програм “ping” текстийг тасралтгүй хэвлэх болно, зогсоохын тулд Enter товчлуур дарах хэрэгтэй.

Суваг үүсгэхдээ `chan` түлхүүр үгийн араас өгөгдлийн төрлийг зааж бичнэ. Зүүн сум `<-` үйлдэл нь сувгаар өгөгдөл илгээх, сувгаас өгөгдөл хүлээн авахад ашиглагдана. `c <- "ping"` заавар нь "ping" текстийг `c` сувгаар илгээ гэсэн утгатай юм. `msg := <- c` заавар нь `c` сувгаас мессеж уншиж `msg` хувьсагчид хадгал гэсэн утгатай.

Go функцүүдийн хооронд суваг ашигласнаар тэдгээрийн ажиллагааг харилцан дараалалд оруулдаг. Тухайлбал `pinger()` функц сувгаар мессеж илгээх бөгөөд түүнийг `printer()` функц хүлээн авах хүртэл уг цэг дээр ажиллагаа нь зогсох болно. Үүнийг мөн өөрөөр түгжээ гэж хэлдэг.

Өмнөх сувгаар дахиад нэг өгөгдөл илгээдэг go функц нэмж юу болохыг харая:

```go
func ponger(c chan string) {
    for i := 0; ; i++ {
        c <- "pong"
    }
}
```

main функцийг дараах байдлаар өөрчлөнө:

```go
func main() {
    var c chan string = make(chan string)

    go pinger(c)
    go ponger(c)
    go printer(c)

    var input string
    fmt.Scanln(&input)
}
```

Дээрх функцийг нэмсэнээр програм "ping" болон "pong" текстүүдийг тасралтгүй хэвлэх болно.

## Сувгийн чиглэл

Сувагт чиглэл зааж болно, ингэснээр зөвхөн хүлээж авах эсвэл илгээх чиглэлтэй болно. Жишээлбэл `pinger()` функцийг дараах байдлаар зөвхөн илгээгч болгон тодорхойлж болно:

```go
func pinger(c chan<- string)
```

Үүний үр дүнд `c` суваг уруу зөвхөн өгөгдөл илгээж болно, энэ сувгаас өгөгдөл унших гэж оролдвол алдаа болох болно.

Үүнтэй төстэйгээр `printer()` функцийг зөвхөн хүлээн авагч болгон өөрчилж болно:

```go
func printer(c <-chan string)
```

## Select

Сувагтай ажиллахад зориулсан `select` түлхүүр үг байдаг. Энэ функц нь `switch` заавартай төстэй ажилладаг. Өөрөөр хэлбэл олон сувгаас сонгож хариу хүлээн авах, боловсруулах зориулалттай заавар юм.

```go
func main() {
    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        for {
            c1 <- "from 1"
            time.Sleep(time.Second * 2)
        }
    }()

    go func() {
        for {
            c2 <- "from 2"
            time.Sleep(time.Second * 3)
        }
    }()

    go func() {
        for {
            select {
            case msg1 := <- c1:
                fmt.Println(msg1)
            case msg2 := <- c2:
                fmt.Println(msg2)
            }
        }
    }()

    var input string
    fmt.Scanln(&input)
}
```

Дээрх програм нь 2 секунд тутамд “from 1” текст, 3 секунд тутамд “from 2” текст хэвлэнэ.

`select` нь өгөгдөл хүлээн авах боломжтой байгаа сувгийг сонгоно  \(эсвэл илгээх боломжтой\). Хэрэв нэгээс олон сувгаас өгөгдөл унших боломжтой болсон байвал санамсаргүйгээр нэгийг нь сонгоно. Хэрэв ямар ч суваг бэлэн биш байвал бэлэн болтол хүлээнэ.

`select` зааврыг мөн ихэвчлэн хугацаа хэтрэлт \(timeout\) тооцоолоход ашигладаг:

```go
select {
case msg1 := <- c1:
    fmt.Println("Мессеж 1", msg1)
case msg2 := <- c2:
    fmt.Println("Мессеж 2", msg2)
case <- time.After(time.Second):
    fmt.Println("timeout")
}
```

`time.After` нь өгөгдсөн тодорхой хугацааны дараа мессеж илгээх шинэ суваг үүсгэдэг. Цаг болоход энэ сувгаар дохио ирнэ, энэ дохио нь одоогийн цагийн мэдээлэл байна. Дээрх жишээнд цагийн мэдээлэл нь чухал биш учраас түүнийг хувьсагчид хадгалаагүй байна.

Мөн `select` зааварт `default` тохиолдол нэмж болно. `default` нь бүх суваг бэлэн бус буюу дохио ирэхгүй байх тохиолдол юм.

```go
select {
case msg1 := <- c1:
    fmt.Println("Мессеж 1", msg1)
case msg2 := <- c2:
    fmt.Println("Мессеж 2", msg2)
case <- time.After(time.Second):
    fmt.Println("timeout")
default:
    fmt.Println("өгөгдөл бэлэн суваг алга!")
}
```

## Буферт суваг

Суваг үүсгэх үед сувгийн багтаамжийг заасан хоёр дахь параметр заах боломжтой:

```go
c := make(chan int, 1)
```

Дээрх заавар нь `1` багтаамжтай суваг үүсгэнэ.

Ердийн суваг нь синхрон байдаг, ө.х сувгийн хоёр талд байгаа илгээгч, хүлээн авагч нь нөгөөгөө бэлэн болтол хүлээдэг. Харин буферт суваг нь асинхрон байдаг; ө.х суваг дүүрэхгүй л бол илгээгч, хүлээн авагчид дээр хүлээлт үүсэхгүй гэсэн үг.




# Параллел давталт

Массив зэрэг өгөгдлийн олонлог дээр нэгэн зэрэг боловсруулалт хийж хугацаа хожих шаардлага олон гардаг. C#, Fortress зэрэг бусад хэлэнд параллел давталт гүйцэтгэхэд зориулсан тусгай заавар байдаг, харин Go хэлэнд үүнийг тусгай зааваргүйгээр хялбархан хийж болно. Дараах хэлбэрийн `for` давталтыг go функцтэй хослуулан хэрэглэж болно:

```go
for i, v := range data {
  go func (i int, v float64) {
		 doSomething(i, v)
		 ...
  } (i, v)
}
```

Параллел давталт ашигласнаар хугацаа маш их хожих болно. Гэхдээ давтаж байгаа зүйлс нь хоорондоо хамааралгүй байх хэрэгтэй.

Жишээ болгон тус бүр 200 миллисекундын ажил гүйцэтгэдэг хэд хэдэн go функц зэрэгцээ ажиллуулж нэг болон олон цөмтэй процессор дээр нийт ажиллах хугацааг нь харьцуулая. Цөмийн тоог тохируулахдаа `runtime.GOMAXPROCS()` функцийг ашиглаж болно. Энэ функцийг `main()` функцийн эхэнд дуудах хэрэгтэй.

200 миллисекундын зохиомол ажил (sleep функц ашиглан) гүйцэтгэх `doJob()` нэртэй функц үүсгэе. Энэ функцийг 50 удаа зэрэгцээ дуудаж ажиллуулая.

```go
package main
import "time"

func doJob(quit chan int) {
    // 200 ms-н ажил
    time.Sleep(time.Millisecond * 200)
    quit <- 1
}

func main() {
    routineQuit := make(chan int)

    for i:=0; i<50; i++ {
      go doJob(routineQuit)
    }

    // бүх функцээс дууссан дохио хүлээх
    for i:=0; i<50; i++ {
     <-routineQuit
    }
}
```

Нийт хугацааг зөв хэмжихийн тулд бүх функцийн ажиллагаа дуустал `main()` функц хүлээх хэрэгтэй болно. Үүнийг шийдэхийн тулд `routineQuit` нэртэй суваг үүсгэсэн байна. Уг сувгаас мессеж ирсэн үед нэг функцийн ажиллагаа дууслаа гэж тооцож болно. Ингээд нийт go функцийн тоогоор сувгаас дууссан дохио хүлээх хэрэгтэй.

Дээрх програмын ажилласан нийт хугацааг тодорхой гаргахын тулд Linux орчинд `time` програмыг ашиглаж болно.

```sh
$ time go run multicore.go
real	0m0.279s
user	0m0.071s
sys	0m0.012s
```

8 цөмтэй процессор дээр 0.279 секундын дотор 59 функц ажиллаж дууссан байна. 4 цөмтэй процессор дээр 0.325 секунд болж байсан. Ажиллах хугацааны хувьд компютерийн хүчин чадлаас хамаараад янз бүр байж болно, гол дүгнэлт бол процессорын цөмийн тоо ихсэх үед параллел давталтын нийт ажиллах хугацаа багасаж байгаа явдал юм.


# Програмын үндсэн элементүүд

Барилга барихад тоосго, мод, шил гэх мэт үндсэн элементүүд хэрэглэхтэй адил програм нь хувьсагч, илэрхийлэл, заавар, функц, тайлбар зэрэг үндсэн элементүүдээс бүтдэг. 

# Хувьсагч

Бид заавар өгч тооцоолсон үр дүнгээ хадгалах хэрэгтэй. Хувьсагч энэ боломжийг олгоно. Хувьсагч бол  өгөгдөл хадгалах үндсэн нэгж юм. Гэхдээ өгөгдлийг түр хугацаанд санах ойд хадгална, ө.х програм ажиллах хугацаанд хадгална. Програм ажиллаж дуусаад санах ойгоос буухад хувьсагчид алга болж санах ойгоос цэвэрлэгдэнэ.

Хувьсагчийн хадгалж байгаа утга нь програм ажиллах явцад хувьсан өөрчлөгдөж байдаг учраас хувьсагч гэж нэрлэдэг.

## Хувьсагчийн төрөл

### Бүхэл тоо

`1`, `87`, `-222` зэрэг тоонууд нь бүхэл тоонууд юм. Бүхэл тоог `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64` төрлүүдээр тодорхойлдог. `8`, `16`, `32`, `64` зэрэг төгсгөл нь тухайн төрөл ямар хэмжээтэй болохыг илэрхийлнэ. Эхний `u` нь тэмдэггүй буюу эерэг тоо гэдгийг илэрхийлнэ.

`uint8` тоог өөрөөр _байт_ \(byte\) гэж нэрлэдэг. Байт нь компютерийн системд маш өргөн хэрэглэгддэг нэгж юм. `1 байт = 8 бит`, `1024 байт = 1 килобайт`, `1024 килобайт = 1 мегабайт` гэх мэт нэрлэдэг.

TODO: _ ашиглах

### Бодит тоо

`5.5`, `8.3`, `-12.6` зэрэг нь хөвөгч цэгтэй бодит тоонууд юм. Бодит тоонд хөвөгч цэгийг ашигладаг. Ө.х `5.0` нь бодит тоо,`5` нь бүхэл тоо юм. Бодит тоог `float32`, `float64` төрлүүдээр тодорхойлно. Эдгээрийг харгалзан _дан_, _давхар_ нарийвчлалтай бодит тоонууд гэж бас хэлдэг.

Нарийвчлал нь тухайн бодит тоон төрөл хичнээн цифр дүрсэлж чадахыг илэрхийлдэг. Төрлийн хэмжээ их байвал илүү олон цифр хадгалах буюу нарийвчлал нь өндөр байна. Жишээ нь, "зургаан цифрийн нарийвчлал" гэдэг нь тухайн төрөл зургаан цифр бүхий бодит тоо хадгалахад хүрэлцэнэ гэсэн үг. Энд хөвөгч цэг нь хаана байрлах нь хамаагүй. Тухайлбал, `123456.0` ба `0.123456` утгууд нь санах ойд хоёулаа ижил хэмжээний зай эзлэх болно.

### Тэмдэгт мөр

Тэмдэгт мөр нь дан эсвэл давхар хашилтад бичигдсэн тэмдэгтийн дараалал буюу текст юм. Давхар хашилтанд нэг л мөр текст бичдэг бол дан хашилтад олон мөр текст бичиж болно.

Жишээ нь, `“Hello world!”` эсвэл

```go
`Hello
   World!`
```

гэж бичнэ.

Тэмдэгт мөрийн уртыг тодорхойлох шаардлага олон гардаг. Үүнд `len()` функцийг ашиглаж  болно:

```go
len("Hello World")
```

Тэмдэгт мөрийн цуваанаас тодорхой нэг тэмдэгтийг ялгах бол `[]` үйлдлийг ашиглана. Жишээ нь текстийн хамгийн эхний тэмдэгтийг `[0]` гэж ялгаж авч болно.  

## Хувьсагчид нэр оноох

Програмд олон хувьсагчийг хооронд нь ялгах зорилгоор нэр өгдөг. Нэр нь утга учиртай, тодорхой, тухайн хувьсагчийн зориулалтад тохирсон байх хэрэгтэй.

Дараах кодонд `a`, `b`  бүхэл тоон хувьсагчид зарласан нь ойлгомжтой байна. Гэвч юунд зориулсан хувьсагчид вэ гэдэг нь ойлгомжгүй байна.

```go
var a int
var b int
```

Дараах зарлалт нь илүү тодорхой, ойлгомжтой байна:

```go
var accountNumber int
var balanceOwed   float64
```

Хувьсагчид нэр оноохдоо дараах дүрмийг мөрдөх хэрэгтэй:

* Нэр нь ойлгомжтой, утга учиртай байх
* Нэр нь үсэг, тоо агуулсан байвал зохино. Доогуур зураас `_` зэрэг тэмдэгтүүдийг нэрэнд ашиглах хэрэггүй
* Пакетын гадна ашиглах хувьсагчийг том үсгээр эхлүүлж бичнэ \(`Sam`\), дотор ашиглах бол жижгээр бичнэ \(`sam`\).
* Go хэлний нөөц үгүүдийг нэр болгон ашиглаж болохгүй. Go хэлэнд 25  түлхүүр үг бий. Эдгээр нь тус бүрдээ өөрийн гэсэн зориулалттай байна.
* Нэрийг хэт товчлохоос зайлсхийх

Зөв нэрсийн жишээ:

```go
average         /* бүх онооны дундаж */
pi             /* pi тогтмол */
numberOfStudents /* анги дахь оюутны тоо */
```

Буруу нэрс:

```go
3rd_entry     /* Тоогоор эхэлсэн */
all$done     /* "$" агуулсан */
the end     /* Сул зай агуулсан */
int         /* Нөөцөлсөн үг */
```

## Хувьсагчийн орших хүрээ ба хугацаа

Хувьсагч нь тодорхой хүрээ, хугацаанд "амьд" байдаг. Хүрээ гэдэг нь тухайн хувьсагч програмын ямар хэсэгт хүчинтэйг илэрхийлнэ. Хүрээнээс хамааран хувьсагчийг глобал болон локал хүрээний хувьсагч гэж ангилдаг.

Глобал хувьсагч нь програмын аль ч хэсэгт хүчинтэй бөгөөд түүний хүрээ нь програм бүтнээрээ байдаг.

```go
package main
import "fmt"

var x string = "Hello World"

func main() {
    fmt.Println(x)
}
func f() {
    fmt.Println(x)
}
```

Локал хувьсагч нь түүний зарлагдсан блок дотор л хүчинтэй бөгөөд блокоос гадна уг хувьсагчид хандах боломжгүй болно.

```go
package main
import "fmt"

func main() {
    var x string = "Hello World"
    fmt.Println(x)
}
func f() {
    // АЛДАА: x хувьсагчид эндээс хандах боломжгүй
    fmt.Println(x)
}
```

## Төрөл хувиргах

Ялгаатай төрлийн хувьсагчдыг нэг илэрхийлэлд оруулж бичих шаардлага олонтаа гардаг. Энэ үед хөрвүүлэгч тэдгээрийг ижил төрөл рүү хувиргахыг оролддог, хэрэв нэг төрөлд оруулж чадахааргүй бол хувьсагчийн төрлийг хувиргахыг шаарддаг.

Хувиргалтыг хоёр аргаар хийдэг.

| Хувиргах үйлдэл | Тайлбар | Жишээ |
| :--- | :--- | :--- |
| төрөл\(хувьсагч\) | Тодорхой төрлүүдийн хооронд хувиргах. | Жнь: int32\(11\) |
| хувьсагч.\(төрөл\) | Тодорхой бус төрлүүдийн хооронд хувиргах | Жнь:  x.\(string\) |

Энд `x` нь `interface` буюу тодорхой бус төрөлтэй хувьсагч. Тухайлбал бүхэл тоон төрлүүдийн хооронд хувиргалт хийх бол төрөл\(хувьсагч\) хувилбарыг ашиглана. Учир нь төрөл нь тодорхой, мөн ойролцоо байна.

Тоон төрлийн хэмжээнээс хамаараад хувиргалт ялгаатай явагдана. Том хэмжээтэй хувьсагчид бага хэмжээтэй утга оноох үед алдаагүй хувиргалт хийнэ. Харин бага хэмжээтэй хувьсагчид том хэмжээтэй утга оноох бол өгөгдлийн зарим хэсэг алдагдах эрсдэлтэй.

`int8 < int15 < int32 < int64`

Жишээлбэл бүхэл, бодит тоог илэрхийлэлд хослуулан хэрэглэх бол төрөл хувиргалт хэрэгтэй болно:

```go
package main
import "fmt"

var won, lost int = 5, 3

func main() {
  ratio:= float32(won) / float32(lost)
  fmt.Printf("хожил/хожигдолын харьцаа = %f\n", ratio)
}
```

Дараах жишээнд `anything` нэртэй тодорхой бус төрөлтэй хувьсагчийг тэмдэгт мөр болгон хувиргаж байна.

```go
var anything interface{} = 123
aString:=anything.(string)
```

Хэрэв хувиргалтад алдаа гарвал програм тасрах болно. Үүнээс сэргийлэхийн тулд үр дүнг дараах байдлаар шалгах хэрэгтэй.

```go
aString, found := anything.(string)
```

Хувиргаж байгаа өгөгдлийн төрлийг мэдэхгүй бол `.(type)` үйлдлийг ашиглаж төрлийг мэдэж болно.

```go
switch v := anything.(type) {
    // төрлөөс хамааран үйлдэл хийх, v нь төрлийн нэр байна
    case string:
        fmt.Println(v)
    case int, int32, int64:
        fmt.Println(v)
    default:
        fmt.Println("unknown")
}
```

## Тогтмол утга

TODO: Програм ажиллах явцад утга нь өөрчлөгдөхгүй өгөгдөл.




## Илэрхийлэл

Энгийн тооцоолол хийхэд илэрхийллийг ашиглана. _Илэрхийлэл_ гэдэг нь тогтмол утга, хувьсагч, үйлдлийг залгасан цуваа юм.

Жишээ нь:

```go
(1 + 2) * 4
a + 1.0
z / math.Sqrt(2.0)
"Тэмдэгт мөр."
2.0 * math.Sin( 3.14159 * angleDegrees/180.0 )
```

Илэрхийллийн зорилго нь тооцоолол, үнэлэлт хийж үр дүн гарган авахад оршдог. _Илэрхийллийн төрөл_ гэдэг нь түүнийг үнэлээд гарах утгын төрөл юм. Үр дүн гарахгүй илэрхийллийг хоосон төрлийн илэрхийлэл гэж үзнэ.

Нийлмэл илэрхийллийг тооцоолоход үйлдлийн зэрэглэл гэсэн ойлголт чухал байдаг. _Үйлдлийн зэрэглэл_ нь илэрхийлэл дэх аль хэсэг эхэлж үнэлэгдэх вэ гэдгийг тодорхойлно.

Жишээ нь, илэрхийлэлд `*`, `/`, `%` зэрэг арифметик үйлдэл нь `+`,  `-` үйлдлээс өндөр зэрэглэлтэй. Тиймээс `a - b * c` илэрхийлэл нь `a - (b * c)` илэрхийлэлтэй ижил юм. Хэрэв үйлдлүүдийг өөрөөр бүлэглэхийг хүсэж байгаа бол хаалтыг ашиглах хэрэгтэй: `(a - b) * c`.

## Арифметик үйлдэл

| Үйлдэл | Утга | Жишээ |
| --- | --- | --- |
| \* | Үржих | x \* y |
| / | Хуваах | x / y |
| % | Хуваасан үлдэгдэл олох | x % y |
| + | Нэмэх | x + y |
| - | Хасах | x - y |
| + \(унар\) | Эерэг тэмдэг | +x |
| - \(унар\) | Сөрөг тэмдэг | -x |

Эдгээр үйлдлээс зөвхөн `％` үйлдэл нь бүхэл тоон операнд шаардана. Бусад үйлдлийг нь дурын тоон төрөл дээр хэрэглэж болно.

## Утга олгох үйлдэл

Олгох үйлдэл нь түүний баруун талд байгаа илэрхийллийг тооцоолоод үр дүнг зүүн талын обектод онооно. Зүүн талын операнд нь өөрчлөгдөх боломжтой обект \(хувьсагч гэж нэрлэдэг\) байна.

| Үйлдэл | Утга | Жишээ | Үр дүн |
| --- | --- | --- | --- |
| = | Утга олгох | x = y | х-д y утгыг онооно |
| := | Зарлаад олгох | x:=10 | x хувьсагчийг шинээр зарлаад 10 утга онооно |
| +=, -=, \*=, /=, %=, &=, ^=, \|=, &lt;&lt;=, &gt;&gt;= | Нийлмэл олгох | x \*= y | `x oper= y` нь `x = x oper (y)` –тэй ижил |

## Нэмэгдүүлэх, хорогдуулах

| Үйлдэл | Утга | Нөлөө | Илэрхийллийн үр дүн |
| --- | --- | --- | --- |
| x++ | Нэмэх | x = x + 1 | x –н утгыг 1-ээр нэмнэ |
| x-- | Хасах | x = x - 1 | x –н утгыг 1-ээр хорогдуулна |

## Харьцуулах

Харьцуулах үйлдэл нь хоёр операндыг харьцуулаад `true` \(үнэн\) эсвэл  `false` \(худал\) утгыг гаргана.

| Үйлдэл | Утга | Жишээ | Үр дүн |
| --- | --- | --- | --- |
| &lt; | Бага | x &lt; y | хэрэв x нь y-ээс бага бол `true`, бусад үед  `false` |
| &lt;= | Бага буюу тэнцүү | x &lt;= y | хэрэв x нь y-тэй тэнцүү буюу бага бол `true`, эсрэг тохиолдолд `false` |
| &gt; | Их | x &gt; y | x нь y-ээс их бол `true`, эсрэг тохиолдолд `false` |
| &gt;= | Их буюу тэнцүү | x &gt;= y | хэрэв x нь y-тэй тэнцүү буюу их бол `true`, эсрэг тохиолдолд `false` |
| == | Тэнцүү | x == y | x нь y-тэй тэнцүү бол `true`, эсрэг тохиолдолд `false` |
| != | Тэнцүү биш | x != y | хэрэв x нь y-тэй тэнцүү биш бол `true`, эсрэг тохиолдолд  `false` |

## Логик үйлдэл

Логик үйлдлүүдийг холбон нийлмэл логик илэрхийлэл зохиож болно. Логик илэрхийлэл нь ихэвчлэн үсэргэх болон заавруудын дарааллыг өөрчлөхөд ашиглагддаг. Go хэлэнд дараах логик үйлдлүүдийг ашигладаг.

| Үйлдэл | Утга | Жишээ | Үр дүн |
| --- | --- | --- | --- |
| && | Логик AND | x && y | x ба y нь хоёулаа `true` үед `true`, бусад үед `false` |
| \|\| | Логик OR | x \|\| y | x ба y нь хоёулаа `false` үед `false`, бусад үед `true` |
| ! | Логик NOT | !x | x нь `false` бол `true`, эсрэг тохиолдолд `false` |

Жишээ нь `deviation` утга `[-0.2, 0.2]` завсараас гадна орших эсэхийг хоёр хэлбэрээр шалгаж болно: `(deviation <  -0.2) || (deviation >  0.2)` эсвэл `!(deviation >= -0.2  &&  deviation <= 0.2)`

## Бит үйлдлүүд

Бит үйлдлүүд нь байт доторхи битүүдтэй “нэг нэгээр” нь ажиллах боломж олгоно. Тухайлбал битүүдийг цэвэрлэх, сэргээх, бүлгээр нь инверс хийх гэх мэт. Мөн битүүдийн байрлалыг шилжүүлэн хөдөлгөж болно. Бит үйлдэл ашигладаг хамгийн энгийн жишээ бол Linux үйлдлийн системийн файл руу хандах зөвшөөрлийн бүтэц юм.

Битүүд нь баруунаасаа зүүн тийш 0-ээс эхлэн дугаарлагдана. Жишээлбэл, `*` тэмдэгтийн бит бүтцийг авч үзэе. Энэ тэмдэгтийн ASCII код нь 42 бөгөөд хоёртын системд 101010 болох юм. 101010 утгыг 8 битээр дүрслэхийн тулд урд нь 00  залгах хэрэгтэй.

```
Бит бүтэц      0 0 1 0 1 0 1 0
Бит дугаар     7 6 5 4 3 2 1 0
```

Go хэлний бит үйлдлүүдийг дараах хүснэгтэд харуулав.

| Үйлдэл | Утга | Жишээ | Үр дүн \(битээр\) |
| --- | --- | --- | --- |
| & | Бит AND | x & y | 1&1=1 , 1&0=0, 0&0=0 |
| \| | Бит OR | x \| y | 1\|1=1, 1\|0=1, 0\|0=0 |
| ^ | Бит XOR | x ^ y | 1^1=1, 1^0=0, 0^1=0, 0^0=1 |
| ~ | Бит NOT \(нэгийн гүйцээлт\) | ~x | ~1=0, ~0=1 |

Бит үйлдлийн операнд нь бүхэл тоон төрөл байх ба үр дүн нь мөн бүхэл тоо байна.

Жишээ болгон `a:=6`, `b:=11` утгуудын хооронд бит үйлдэл хийе.

```tex
 a & b
```

Бүхэл тоон утгын тодорхой битүүдийг бит AND үйлдэл ашиглан 0-ээр цэвэрлэж болно. Цэвэрлэхэд ашиглаж байгаа битүүдийг бит маск гэж хэлдэг. Жишээ нь, `0xFF` бит маскаар AND үйлдэл хийвэл тооны бага найман битээс бусад бүх битийг цэвэрлэнэ.

```go
a &= 0xFF;       // a = a & 0xFF; бичиглэлтэй адил
```

Энэ жишээнд харж байгаагаар нийлмэл олгох `&=` үйлдлийг мөн ашиглаж болж байна. Мөн бусад бит үйлдлүүдийг олгох үйлдэлтэй нийлүүлэн хэрэглэж болно.

Бит үйлдлүүд нь мөн дараагийн бит үйлдэлд зориулан бит маск бэлдэхэд ашиглагдана. Жишээ нь, `0x20` бит бүтцэд зөвхөн 5-р бит нь 1 байна. Тиймээс `~0x20` илэрхийллийг 5-р битээс бусад битийг 1 болгох маск болгон ашиглаж болж байна:

```go
a &= ~0x20;    // 5-р битийг цэвэрлэх
```

`~0x20` бит маскийг `0xFFFFFFDF` гэж ашиглах нь илүү дээр юм, учир нь энэ нь машины бүтцээс хамааралгүй хүссэн үр дүнг гарган авахад илүү тохиромжтой, мөн хүн уншихад илүү ойлгомжтой байна.

Мөн `|` \(OR\) ба `^` \(exclusive OR\) үйлдлүүдийг тодорхой битүүдийг сэргээх, цэвэрлэхэд ашиглаж болно.

Жишээлбэл:

```go
int mask = 0xC;  // битээр 00001100
a |= mask;       // 2 ба 3 дугаартай битүүдийг сэргээх
a ^= mask;       // 2 ба 3 дугаартай битүүдийг инверслэх
```

Нэгэн ижил бит маск ашигласан хоёр дахь инверс нь эхний утгатай адил үр дүнг гаргана. Ө.х, `b^mask^mask` нь `b` хувьсагчийн анхны утгыг гаргана. Энэ чанарыг ашиглан хоёр бүхэл тооны утгуудыг гуравдагч хувьсагч ашиглалгүй хооронд нь сольж болно:

```go
a ^= b;          // a = a ^ b;
b ^= a;          // b –д a-н анхны утгыг оноох
a ^= b;          // a –д b-н анхны утгыг оноох
```

Энэ жишээний эхний хоёр илэрхийлэл нь `b = b^(a^b)` эсвэл  `b = (a^b)^b` илэрхийлэлтэй ижил юм. Үр дүн нь `b = a` болно. Энэ үед гуравдахь илэрхийлэл \(`a` ба `b` –ийн анхны утгуудыг ашиглан\) нь `a = (a^b)^a` буюу `a = b` болгоно.

## Хаяглах үйлдлүүд

Обектийн санах ой дахь хаягийг тодорхойлох, массивын элемент индекслэх, бүтцийн гишүүнд хандах зэрэг нь хаяглах үйлдэл юм.

| Үйлдэл | Утга | Жишээ | Үр дүн |
| --- | --- | --- | --- |
| & | Хаяг авах | &x | х-г заах хаяг |
| \[\] | Индекслэх | x\[y\] | x  массивын y байрлал дахь элемент |
| . | Бүтцийн гишүүнд хандах | x.y | x бүтцийн y нэртэй гишүүн |

## Бусад үйлдлүүд

Дээрх ангиллуудын  алинд ч орохооргүй дараах хэдэн үйлдэл байна.

| Үйлдэл | Утга | Жишээ | Үр дүн |
| --- | --- | --- | --- |
| \( \) | Функц дуудах | log\(x\) | Заасан функцэд  удирдлагыг шилжүүлнэ |
| len\(\) | Обектийн хэмжээ олох | len\(x\) | х-н санах ойд эзлэх хэмжээ, урт |
| make\(\) | Обект эсвэл обектуудын олонлог үүсгэх | make\(\[\]int, 10, 10\) | 10 урттай бүхэл тоон массив үүсгэнэ |
| new\(\) | Шинэ обектод санах ой хувиарлах | new\(T\) | T төрлийн хэмжээтэй санах ой хувиарлаад түүний хаягийг буцаана |
| append\(\) | Хоёр массивыг залгах | append\(s0, 2\) | s0 массив дээр 2 утгыг нэмж залгана |
| copy\(\) | Массивыг хуулах | copy\(b, "Hello"\) | b массив руу Hello текстийг хуулна |
| delete\(\) | Майпаас элемент хасах | delete\(m, k\) | m майпаас k түлхүүртэй өгөгдлийг устгана |
| .\(type name\) | Төрөл хувиргах | x.\(string\) | х-г string болгон хөрвүүлнэ |


## Тайлбар

Тайлбар нь програмын элементүүдийг тайлбарлахад хэрэглэгдэнэ. Хөрвүүлэгч нь тайлбарыг алгасаж хөрвүүлдэг, ө.х эцсийн машины кодонд тайлбар нь орохгүй, нөлөө үзүүлэхгүй гэсэн үг.

Тайлбарыг хоёр хэлбэрээр хийж болно:

* Нэг мөр тайлбар нь `//`-аар эхлэх ба мөрийн төгсгөл дээр төгсөнө
* Блок тайлбар нь `/*  тайлбар  */`  хэлбэртэй бичигдэнэ

Зарим хүн програмыг зөвхөн компютерт зориулсан зааврууд гэж ойлгодог. Энэ нь буруу ойлголт юм. Зөвхөн машинд зориулж програм бичдэг гэвэл өрөөсгөл зүйл болно. Тийм програмууд нь уншиж ойлгох, засварлахад маш хүнд байдаг бөгөөд заримдаа зохиогч нь өөрөө ойлгохгүй байх нь ч бий.

Тэгэхээр, програмын эх код нь компютерт зориулсан зааврууд мөн боловч хамгийн чухал нь хүн уншихад ойлгомжтой, тодорхой байх хэрэгтэй. Тийм учраас програмдаа хангалттай сайн тайлбар оруулж байх хэрэгтэй.

Үүнд дараах дүрмийг мөрдлөг болгох хэрэгтэй.

* Нэг функц хоёр хуудсаас урт сунжирсан байх хэрэггүй
* Олон давхар if зэрэг төвөгтэй нийлмэл логикоос зайлсхийх хэрэгтэй
* Урт сунжирсан команд, заавруудаас зайлсхийх хэрэгтэй

Програмчлалын хэл бүрт эх кодын формат нь өөр өөр стандарттай байдаг. Go хэлний хувьд эх кодыг автоматаар нэг форматад оруулдаг багаж бий.

Ер нь “Би энэ програмыг зөвхөн өөрөө өөртөө бичиж байна, тиймээс надад тайлбар хэрэггүй” гэж бодох хэрэггүй. Эхлээд код бичиж байх үед бүх зүйл тодорхой харагдах боловч түүнийгээ долоо хоногийн сүүлээр дахин харахад ойлгомжгүй, нууцлаг зүйлүүд их гарах болно. Тиймээс програмдаа тайлбар хийж байх хэрэгтэй.

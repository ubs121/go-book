# NoSQL төрлийн баазууд

NoSQL төрлийн өгөгдлийн сангуудад хэд хэдэн нийтлэг шинж байдаг

* схем байхгүй
* ихэнхи нь уялдаат бус  \(non-relational\)
* хэвтээ чиглэлт өргөтгөх, тэлэх боломжтой учраас тархсан орчинд \(distributed\) сайн ажилладаг 
* асар их хэмжээний өгөгдлийг хадгалах чадвартай
* нээлттэй эхтэй

Гэхдээ зарим ялгаа бий. Эдгээрийг өгөгдлийг хэрхэн хадгалж байгаа байдлаар нь Key-Value, Column Store, Document Store, Graph гэж ангилж болно.

* _Key-Value_:  BoltDB, LevelDB, OpenLDAP
* _Column Store_:  Hadoop, Cassandra
* _Document Store_:  MongoDB, CouchDB
* _Graph_: Cayley, Neo4j, Titan

Тус бүрээс төлөөлөл болгон BoltDB, MongoDB, Cayley өгөгдлийн санг үзэе.

## MongoDB-тэй ажиллах

MongoDB нь Document Store төрлийн өгөгдлийн сангийн систем юм. Схемгүй учраас тойм загвар гаргах, хөгжүүлэлт эхлүүлэхэд маш хялбар, хурдан байдаг.

Өгөгдлийг JSON маягийн баримтууд болгон хадгалдаг, энэ бүтцээ BSON гэж нэрлэдэг. Олон BSON баримтыг нийтэд нь цуглуулга гэж нэрлэнэ.

BSON өгөгдөл:

```json
{
        "_id" : "502fbbd6fec1300be858767e",
        "нэр" : "Сүхбаатар",
        "эцгийн_нэр" : "Ууганбаяр",
        "бүртгэсэн_огноо" : ISODate("2014-04-18T15:59:18.646Z")
}
```

MongoDB-тэй ажиллах дараалал:

* Шаардлагатай сангуудыг импортлох. MongoDB-тэй ажиллахад зориулсан `mgo` нэртэй сан бий.
* `mgo.Dial()` функцээр MongoDB өгөгдлийн сан руу холбогдох
* Холболтоор дамжуулан өгөгдөлтэй ажиллана: хадгалах, хайх, устгах гэх мэт

### Шаардлагатай санг импортлох

Юуны өмнө дараах командаар `mgo` санг татаж суулгах хэрэгтэй

```sh
$ go get gopkg.in/mgo.v2
```

Дараа нь програмдаа импортлоно.

```go
import (
        "gopkg.in/mgo.v2"
        "gopkg.in/mgo.v2/bson"
)
```

### Өгөгдлийн санд холбогдох

```go
session, err := mgo.Dial("server1.example.com")
if err != nil {
  panic(err)
}
defer session.Close()

// нэмэлт тохиргоо хийж болно
session.SetSafe(&mgo.Safe{})
```

`session.SetSafe()` функц нь аюулгүй бичилтийн горимийг тохируулна. `mgo.Safe` нь бичилтийг аюулгүй, найдвартай гүйцэтгэх шаардлагатай болохыг заана. Бичилтийн аюулгүй байдлыг дээшлүүлэх үед бичих хурд багасдаг сөрөг талтай.  

MongoDB нь өндөр хурдан, тасралтгүй ажиллагааг маш сайн хангасан байдаг. Тухайлбал найдвартай байдлыг дээшлүүлэх зорилгоор олон машин дээр тархан байрласан MongoDB баазууд ашиглах боломжтой байдаг. Ийм зохион байгуулалттай өгөгдлийн сангуудийн системийг кластер гэж нэрлэдэг.

Дараах жишээнд server1.example.com болон server2.example.com серверүүд рүү зэрэг холболт үүсгэж байна.

```go
session, err := mgo.Dial("server1.example.com,server2.example.com")
```

Дээрх маягийн холболт үүсгэхэд програм бүх хүсэлтийг хоёр сервер рүү зэрэг илгээнэ. Аль нэг унтарсан эсвэл эвдэрсэн үед програм үлдсэн сервертэй нь ажиллана.

Энэ үед тархан байрласан өгөгдлийн сангуудын хооронд өгөгдлийн зөрүү үүсэх болно. Үүнийг гар аргаар ижилсүүлэх эсвэл sharding тохируулга хийх замаар автоматаар шийдэх хувилбарууд бий.

### Өгөгдөл хадгалах, засах

```go
db := session.DB("testDb")
c:=db.C("Person")

err = c.Insert(&Person{"Ale", "+55 53 8116 9639"},
          &Person{"Cla", "+55 53 8402 8510"})
if err != nil {
    panic(err)
}
```

`Insert()` функцээс гадна `Save()`,  `UpdateId()` функцүүдийг өгөгдөл засахад ашиглаж болно.

### Өгөгдөл хайх

Нэг мөр унших

```go
result := Person{}

c:=db.C("Person")
err = c.Find(bson.M{"нэр": "Ууганбаяр"}).One(&result)
if err != nil {
  panic(err)
}

fmt.Println("Эцгийн нэр:", result.LastName)
```

### Id-аар нэг мөр унших

```go
c := db.C("Person")
q := c.FindId("502fbbd6fec1300be858767e")

// bson.M төрлөөр өгөгдөл уншиж байна
var resp bson.M
if err = q.One(&resp); err!=nil {
  panic(err)
}

fmt.Println("Эцгийн нэр:", resp["LastName"])
```

### Олон мөр өгөгдөл унших \(TODO: жишээг засах\)

```go
// args бүтцээр шаардлагатай аргументийг дамжуулна

// ...
q := c.Find(args.Query)

// талбарууд сонгох
if args.Select != nil {
  q.Select(args.Select)
}

// алгасах
if args.Skip > 0 {
  q.Skip(args.Skip)
}

// хязгаарлах
if args.Limit > 0 {
  q.Limit(args.Limit)
}

// эрэмбэлэх
if len(args.Sort) > 0 {
  q.Sort(args.Sort...)
}

var resp []bson.M
err = q.All(&resp)
```

### Өгөгдөл дээр Javascript код ажиллуулах

Өгөгдлийн сан нь өгөгдөл хадгалах үндсэн үүрэгтэй байдаг. Гэхдээ ихэнхи SQL төрлийн өгөгдлийн сангууд өгөгдлөөс гадна програм хадгалах боломжийг олгодог.

Бааз дээр хадгалсан програмыг ихэвчлэн stored procedure гэж нэрлэдэг. Үүнтэй төстэйгээр MongoDB өгөгдлийн санд javascript код үүсгэж хадгалаад өгөгдөл боловсруулахад ашиглаж болно. Үүнийг сервер талын javascript гэж нэрлэдэг. Мөн eval функцийн тусламжтайгаар javascript кодыг заавал баазад хадгалахгүйгээр шууд ажиллуулж болно.

Дараах жишээнд `hello()` нэртэй javascript кодыг MongoDB дээр ажиллуулж байна.

```go
// javascript эх код
src:=`
function hello(p) {
  var s = p.name;
  return "Hello " + s;
}
`

// дамжуулах параметрүүд
params:= bson.M{"name": "Solongo"}

var runResult bson.M
err := _db.Run(bson.D{
    {"eval", src},
    {"args", []interface{}{params}},
    {"nolock", true}},
    &runResult)

// runResult үр дүнг ашиглах
```

### Өгөгдлийн схем үүсгэх

Өгөгдлийн схем үүсгэж болно, гэхдээ ихэнхидээ шаардлагагүй. Схем үүсгэхгүйгээр `bson.M` төрлийг ямар ч төрлийн мэдээлэлд ашиглаж болно, энэ нь map төрөлтэй ижилхэн.

`Person` баримтад \(BSON\) харгалзах Go бүтэц:

```go
type Person struct {
    Id         bson.ObjectId   "_id,omitempty"
    FirstName  string          "нэр"
    LastName   string          "эцгийн_нэр"
    Inserted   time.Time       "бүртгэсэн_огноо"
}
```

Талбарын нэрийн ард мета өгөгдөл тодорхойлсон байна. Жишээ нь `FirstName string` тодорхойлолтын ард `нэр` гэж бичсэн байна. Энэ нь `Firstname` талбарыг хадгалах, дамжуулах үед `нэр` гэж нэрлэгдэнэ, харин go бүтэц дотор `FirstName` гэж нэрлэгдэнэ гэдгийг заана.

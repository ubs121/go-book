##  Go функц (goroutine)

Go функц гэдэг нь бусад функцтэй зэрэгцэн ажиллах функц юм. Зэрэгцээ ажиллана гэдэг нь нэг зорилгын дор олон ажлыг зэрэг амжуулах тухай юм. 

Бид програмын зохиомжоо хийх үедээ зэрэг "амжуулж" болох хэсгүүдийг олж харж чаддаг, тэдгээрийн холбоосыг сайн зохиомжилж чаддаг байх хэрэгтэй. Ихэвчлэн том хэмжээний ажлыг жижиг хэсгүүдэд хувааж ямар хэсгүүд нь зэрэг хийгдэх боломжтой, зэрэг ажиллахдаа тэдгээр хэсгүүд хоорондоо хэрхэн мэдээлэл солилцох зэргийг тооцно гэсэн үг. Зэрэгцээ боловсруулалтын ойрхон жишээ гэвэл бид компютерийн хулгана, гар, дэлгэцийг зэрэг ашигладаг. Хэрэв эдгээр төхөөрөмжүүд дараалж ажилладаг байсан бол хэчнээн болхи, үр ашиггүй байхыг та төсөөлж байгаа бизээ.

Ажлыг зэрэг гүйцэтгэх, хамгийн бага хугацаанд дуусгах тухай бодох нь хөгжүүлэгчийн ур чадвараас ихээхэн хамааралтай болох нь ойлгогдоно. Гэхдээ зэрэгцээ боловсруулалтад мөрддөг ерөнхий дүрмүүд бий.

* Хэрэв хэт жижиг ажлууд бол тэдгээрийг үүсгэх, ачаалах, цэвэрлэх гэх мэт "удирдлагын" шинжтэй үйлдлүүд нь ихсэх болно. Энэ нь ажлын хугацааг илүү уртгасгаж болно.

* Хэрэв хэт том бол зөвхөн нэг ажлыг дуусгахын тулд удаан хүлээлт үүсгэх болно. Энэ нь зэрэг боловсруулахын давуу талыг үгүй болгоно.

* Үл хамаарах хэсгүүдийн хооронд ашиглагдах дундын өгөгдлийг маш бага байлгах хэрэгтэй. Ялангуяа дундын санах ойн муж руу бичих үйлдэл нь удаашруулах, түгжээ үүсгэх гэх мэт асуудалтай байдаг. Харин унших үйлдэл нь асуудал багатай байдаг.

* Өгөгдлийг аль болох далдлах, локал ашиглах. Локал буюу кээшэд байгаа өгөгдлийг унших, бичихэд илүү хурдан байдаг.

Зэрэгцээ програмчлалыг сайн ойлгохын тулд бодит ертөнц дээрх процессуудыг сайн ажиглах хэрэгтэй. Жишээ нь зам дээр явж байгаа машинуудыг харж болно. Машинууд бие биенээс үл хамааран урагшлах нь зэрэгцээ өрнөж байгаа процесс, гэхдээ тэд осол аваар гаргахгүйн тулд хоорондоо ойлголцох (баруун зүүн дохио өгөх) шаардлагатай болдог.

Go функц үүсгэхийн тулд функцийн нэрний өмнө `go` түлхүүр үгийг тавьж дуудах хэрэгтэй:

```go
package main
import "fmt"

func f(n int) {
    for i := 0; i < n; i++ {
        fmt.Println(n, ":", i)
    }
}

func main() {
    go f(10) // main()-тэй параллел goroutine эхлүүлж байна
    
    var input string
    fmt.Scanln(&input)
}
```

Дээрх програм нь хоёр функцээс тогтоно. Эхнийх нь `main()` функц өөрөө байна, хоёр дахь нь `go f(10)` гэсэн дуудалтаар үүснэ. Ердийн үед функц дуудахад тухайн функц дотор бичигдсэн бүх заавар ажиллаж дууссаны дараа дараагийн мөрд програмын удирдлага шилждэг. Go функцийн тохиолдолд програмын удирдлага шууд дараагийн мөрд шилжинэ, ө.х Go функц дотор бичигдсэн зааврууд ажиллаж дуусахыг хүлээхгүй гэсэн үг. Үүнийг нотлон харуулах зорилгоор `fmt.Scanln()` функцийг дуудсан байгаа. Энэ функц нь гараас мэдээлэл оруулахыг хүлээнэ, хэрэв ингэж хүлээхгүй бол програмын ажиллагаа шууд тасарч `f()` функц тоонуудыг хэвлэж амжихгүй тасрах болно.

Go функц нь маш хөнгөн байдаг бөгөөд олон тоогоор үүсгэх боломжтой байдаг. Жишээлбэл 100 ширхэг go функцийг дараах байдлаар үүсгэж болно:

```go
func main() {
    for i := 0; i < 100; i++ {
        go f(i)
    }
    var input string
    fmt.Scanln(&input)
}
```

Дээрх програмыг ажиллуулахад go функцүүд дарааллаар ажиллаад байгаа мэт харагдаж байгааг ажиглаарай. Ө.х тоонууд дэс дарааллын дагуу хэвлэгдэж байна. Үнэндээ go функцүүдыг дуудсан дарааллаар маш хурдан ажиллаж дуусаад байгаа учраас тэгж харагдаж байгаа юм. Зэрэг ажиллаж байгааг нотлохын тулд тоо хэвлэлтүүдийн хооронд бага зэрэг хүлээлт оруулая. Үүнд `time.Sleep` ба `rand.Intn` функцүүдийг хослуулан ашиглаж болно:

```go
package main

import (
  "fmt"
  "time"
  "math/rand"
)

func f(n int) {
    for i := 0; i < 10; i++ {
        fmt.Println(n, ":", i)
        amt := time.Duration(rand.Intn(250))
        time.Sleep(time.Millisecond * amt)
    }
}

func main() {
    for i := 0; i < 10; i++ {
        go f(i)
    }
    var input string
    fmt.Scanln(&input)
}
```

Өөрчлөлтийн үр дүнд `f()` функц бүр 0 – 10 хүртэлх тоог 0 - 250 миллисекундын завсарлагатайгаар хэвлэнэ. Завсарлага оруулснаар бусад функцүүд зэрэг ажиллаж ижил үйлдлийг хийж байгаа гэдгийг харах боломжтой болсон байна.

## Суваг

Зэрэгцээ ажиллаж байгаа хоёр go функц хоорондоо мэдээлэл солилцохдоо _суваг_ ашиглана. Дараах програмд суваг ашигласан байна:

```go
package main
import (
  "fmt"
  "time"
)

func pinger(c chan string) {
    for i := 0; ; i++ {
        c <- "ping"
    }
}

func printer(c chan string) {
    for {
        msg := <- c
        fmt.Println(msg)
        time.Sleep(time.Second * 1)
    }
}

func main() {
    var c chan string = make(chan string)

    go pinger(c)
    go printer(c)

    var input string
    fmt.Scanln(&input) // Enter дарахыг хүлээх
}
```

Энэ програм "ping" текстийг тасралтгүй хэвлэх болно, зогсоохын тулд Enter товчлуур дарах хэрэгтэй.

Суваг үүсгэхдээ `chan` түлхүүр үгийн араас өгөгдлийн төрлийг зааж бичнэ. Зүүн сум `<-` үйлдэл нь сувгаар өгөгдөл илгээх, сувгаас өгөгдөл хүлээн авахад ашиглагдана. `c <- "ping"` заавар нь "ping" текстийг `c` сувгаар илгээ гэсэн утгатай юм. `msg := <- c` заавар нь `c` сувгаас мессеж уншиж `msg` хувьсагчид хадгал гэсэн утгатай.

Go функцүүдийн хооронд суваг ашигласнаар тэдгээрийн ажиллагааг харилцан дараалалд оруулдаг. Тухайлбал `pinger()` функц сувгаар мессеж илгээх бөгөөд түүнийг `printer()` функц хүлээн авах хүртэл уг цэг дээр ажиллагаа нь зогсох болно. Үүнийг мөн өөрөөр түгжээ гэж хэлдэг.

Өмнөх сувгаар дахиад нэг өгөгдөл илгээдэг go функц нэмж юу болохыг харая:

```go
func ponger(c chan string) {
    for i := 0; ; i++ {
        c <- "pong"
    }
}
```

main функцийг дараах байдлаар өөрчлөнө:

```go
func main() {
    var c chan string = make(chan string)

    go pinger(c)
    go ponger(c)
    go printer(c)

    var input string
    fmt.Scanln(&input)
}
```

Дээрх функцийг нэмсэнээр програм "ping" болон "pong" текстүүдийг тасралтгүй хэвлэх болно.

## Сувгийн чиглэл

Сувагт чиглэл зааж болно, ингэснээр зөвхөн хүлээж авах эсвэл илгээх чиглэлтэй болно. Жишээлбэл `pinger()` функцийг дараах байдлаар зөвхөн илгээгч болгон тодорхойлж болно:

```go
func pinger(c chan<- string)
```

Үүний үр дүнд `c` суваг уруу зөвхөн өгөгдөл илгээж болно, энэ сувгаас өгөгдөл унших гэж оролдвол алдаа болох болно.

Үүнтэй төстэйгээр `printer()` функцийг зөвхөн хүлээн авагч болгон өөрчилж болно:

```go
func printer(c <-chan string)
```

## Буферт суваг

Суваг үүсгэх үед сувгийн багтаамжийг заасан хоёр дахь параметр заах боломжтой:

```go
c := make(chan int, 3)
```

Дээрх заавар нь `3` багтаамжтай суваг үүсгэнэ.

Ердийн суваг нь синхрон байдаг, ө.х сувгийн хоёр талд байгаа илгээгч, хүлээн авагч нь нөгөөгөө бэлэн болтол хүлээдэг. Харин буферт суваг нь асинхрон байдаг; ө.х суваг дүүрэхгүй л бол илгээгч, хүлээн авагчид дээр хүлээлт үүсэхгүй гэсэн үг.


## Select

Сувагтай ажиллахад зориулсан `select` түлхүүр үг байдаг. Энэ функц нь `switch` заавартай төстэй ажилладаг. Өөрөөр хэлбэл олон сувгаас сонгож хариу хүлээн авах эсвэл илгээх юм. 

`select` нь өгөгдөл хүлээн авах боломжтой байгаа сувгийг сонгоно (эсвэл илгээх боломжтой). Хэрэв нэгээс олон сувгаас өгөгдөл унших боломжтой болсон байвал санамсаргүйгээр нэгийг нь сонгоно. Хэрэв ямар ч суваг бэлэн биш байвал бэлэн болтол хүлээнэ.

```go
func main() {
    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        for {
            c1 <- "from 1"
            time.Sleep(time.Second * 2)
        }
    }()

    go func() {
        for {
            c2 <- "from 2"
            time.Sleep(time.Second * 3)
        }
    }()

    go func() {
		// олон удаа давтах
        for {
            // боломжит сувгаас сонгож унших
            select {
            case msg1 := <- c1:
                fmt.Println("Мессеж 1", msg1)
            case msg2 := <- c2:
                fmt.Println("Мессеж 2", msg2)
            default:
                fmt.Println("өгөгдөл бэлэн суваг алга!")
            }
        }
    }()

	// товч дартал програмыг дуусгалгүй хүлээлгэх
    var input string
    fmt.Scanln(&input)
}
```

Дээрх програм нь 2 секунд тутамд "from 1" текст, 3 секунд тутамд "from 2" текст хэвлэнэ.

# Хандалтыг зохицуулах (Synchronize)

Go функцүүдийн нөөцийн төлөө өрсөлдөөнийг зохицуулах хэд хэдэн арга бий.

## Суваг ашиглан зохицуулах

Нэгдүгээрт суваг ашиглаж болно. Сувгийн зориулалт нь go функцүүдийн хооронд мессеж/өгөгдөл дамжуулах гэдгийг бид мэднэ. Үүнээс өөрөөр мөн go функцүүдийг зохицуулах (синхрончлох) зорилгоор ашиглаж болно.

```go
type Ball struct{ hits int }

// тоглогч функц
func player(name string, table chan *Ball) {
	for {
		ball := <-table // ширээнээс ойсон бөмбөг авах
		ball.hits++     // цохилтын тоог нэмэх (дундын нөөц)
		fmt.Println(name, ball.hits)
		time.Sleep(100 * time.Millisecond)

		// бөмбөгийг ширээ рүү буцаах
		table <- ball
	}
}

func main() {
	// ping-pong ширээнд зориулсан суваг
	table := make(chan *Ball)

	// хоёр тоглогч үүсгэх
	go player("ping", table)
	go player("pong", table)

	// бөмбөгийг шидэж тоглоомыг эхлүүлэх
	table <- new(Ball)

	// хэсэг хугацаанд тоглох боломж олгох
	time.Sleep(2 * time.Second)

	<-table // тоглоом дууслаа; бөмбөгийг барих
}
```

Энэ жишээний `table` суваг нь зөвхөн өгөгдөл (бөмбөг) дамжуулах зорилготой биш, мөн нөөцийн (цохилтын тоо) хандалтыг зохицуулах зорилготой байна.

## Mutex ашиглан зохицуулах

Зарим тохиолдолд зохицуулагч обект ашиглан өгөгдөлд хандалтыг синхрончлох нь оновчтой байдаг. Энэ зорилгоор `sync.Mutex` обектыг ашиглаж болно.

Энэ төрлийн синхрончлолд дундын нөөц рүү тухайн мөчид зөвхөн нэг go функц хандахыг зөвшөөрөх замаар зохицуулалт хийдэг. Хэрэв тэр нэг go функц нь алдаа гаргавал түгжрэх нөхцөл үүсэж болно. Тийм учраас өгөгдлийн бүтэцээ параллел ажиллагаанд зориулан нарийн зохиомжлох хэрэгтэй.

Дараах жишээнд `atomicInt` нэртэй бүхэл тоо үүсгэсэн байна. `mutex` обект ашиглан зохицуулсанаар `atomicInt` хувьсагчид олон go функц хандаж өөрчлөлт хийхэд аюулгүй болж байна.

```go
var atomicInt int // дундын нөөц

var mutex sync.Mutex
mutex.Lock()
atomicInt++ // нөөцөд хандах
mutex.Unlock()
```


## for/select ашиглан зохицуулах

Жишээ болгон тойрог дараалал руу бичих, унших үйдлийг зэрэг гүйцэтгэх producer-consumer загварын функц хэрхэн зохиомжлохыг үзэе. Өгөгдөл `producer` сувгаас орж ирэх бөгөөд дараалал руу заасан байрлалд бичигдэнэ. Нөгөө талаас `consumer` сувгаар дамжин тасралтгүй унших үйлдэл хийгдэнэ. Унших болон бичих үйлдэл нь бие биенээсээ хамааралгүй хийгдэнэ. Дундын нөөц болох `rb` обектод хандалтыг `for/select` хослолоор зохицуулж байна.

```go
func circularQueue[T any](size int, producer chan *T, consumer chan *T) {
	rb := make([]*T, size) // дундын нөөц (ring buffer)
	writeIndex := 0        // бичих байрлал
	readIndex := 0         // унших байрлал

	// нөхцөлгүй үргэлжлэн давтах
	for {
		select {
		case m := <-producer: // 'producer' сувгаас уншихыг оролдох
			if m != nil {
				// тойрогт нэмэх
				rb[writeIndex%size] = m
				writeIndex++
			}
		default:
			//  унших өгөгдөл байхгүй тохиолдолд
			// 'consumer' суваг руу илгээхийг оролдох

			// дараагийн илгээх өгөгдөл
			m := rb[readIndex%size]
			if m != nil {
				consumer <- m // илгээх
				readIndex++

				// завсарлага
				// time.Sleep(100 * time.Millisecond)
			}
		}
	}
}
```

## Параллел давталт

Массив зэрэг өгөгдлийн олонлог дээр нэгэн зэрэг боловсруулалт хийж хугацаа хожих шаардлага олон гардаг. C#, Fortress зэрэг бусад хэлэнд параллел давталт гүйцэтгэхэд зориулсан тусгай заавар байдаг, харин Go хэлэнд үүнийг тусгай зааваргүйгээр хялбархан хийж болно. Дараах хэлбэрийн `for` давталтыг go функцтэй хослуулан хэрэглэж болно:

```go
for i, v := range data {
  go func (i int, v float64) {
		 doSomething(i, v)
		 ...
  } (i, v)
}
```

Параллел давталт ашигласнаар нийт ажлын хугацааг багасгаж болно. Гэхдээ давтаж байгаа зүйлс нь хоорондоо хамааралгүй байх хэрэгтэй.

Жишээ болгон тус бүр 200 миллисекундын ажил гүйцэтгэдэг хэд хэдэн go функц зэрэгцээ ажиллуулж нэг болон олон цөмтэй процессор дээр нийт ажиллах хугацааг нь харьцуулая. 

Эхлээд 200 миллисекундын зохиомол ажил (time.Sleep функц ашиглан) гүйцэтгэх `doJob()` нэртэй функц үүсгэе.

```go
type Request struct{ Name string }
type Response struct{ Data string }

// ажил гүйцэтгэх
func doJob(request *Request) *Response {
	time.Sleep(200 * time.Millisecond) // 200 ms-н ажил

	// хариу илгээх
	return &Response{Data: request.Name + " дууслаа"}
}
```

Энэ функцийг 60 удаа зэрэгцээ дуудаж ажиллуулая.

```go
func parallelFor() {
	n := 60
	jobChan := make(chan *Response)

	// ажлын жагсаалт үүсгэх
	var requests []Request
	for i := 0; i < n; i++ {
		requests = append(requests, Request{"task" + strconv.Itoa(i)})
	}

	// параллел давталт
	for _, req := range requests {
		go func(r *Request) {
			reply := doJob(r)
			jobChan <- reply
		}(&req)
	}

	// бүх функцээс өгөгдөл хүлээх
	for i := 0; i < len(requests); i++ {
		resp := <-jobChan
		println(resp.Data)
	}
}
```

Сүүлийн давталтанд бүх сувгаас өгөгдөл ирж дуусахыг хүлээж байна. Бүх сувгаас мессеж ирсэн үед parallelFor() функцийн ажиллагаа дуусна.

Дээрх програмын ажилласан нийт хугацааг тодорхой гаргахын тулд Linux орчинд `time` програмыг ашиглаж болно.

```sh
$ time go run multicore.go
real	0m0.279s
user	0m0.071s
sys	0m0.012s
```

8 цөмтэй процессор дээр 0.279 секундын дотор 60 функц ажиллаж дууссан байна. 4 цөмтэй процессор дээр 0.325 секунд болж байсан. Ажиллах хугацааны хувьд компютерийн хүчин чадлаас хамаараад янз бүр байж болно, гол дүгнэлт бол процессорын цөмийн тоо ихсэх үед параллел давталтын нийт ажиллах хугацаа багасаж байгаа явдал юм. 

Цөмийн тоог тохируулахдаа `runtime.GOMAXPROCS()` функцийг ашиглаж болно. Энэ функцийг ихэвчлэн `main()` функцийн эхэнд дууддаг.

## Ordered results from channel

```go
func orderedResults(n int) {
	// сувгийн слайс үүсгэх
	results := make([]chan *Response, n)

	for i := 0; i < n; i++ {
		//  'i' ажилд зориулж суваг үүсгэх
		results[i] = make(chan *Response)

		// шинэ ажил эхлүүлэх
		go func(order int) {
			reply := doJob(&Request{Name: "task" + strconv.Itoa(order)})
			results[order] <- reply
		}(i)
	}

	// үр дүнг дарааллаар нь цуглуулах
	for i := 0; i < n; i++ {
		result := <-results[i]
		fmt.Println("result ", result)
	}
}
```

## WaitGroup

Зарим тохиолдолд хэдэн go функц хэрэгтэй болохыг мэдэх боломжгүй байдаг. Энэ тохиолдолд `WaitGroup` обект ашиглаж болно. Хэсэг go функц эхлүүлээд бүгдийг нь ажиллаж дуусахыг хүлээх хэрэгтэй бол `WaitGroup` ашиглаж болно.

TODO: Worker pool pattern

```go
var wg sync.WaitGroup

for _, req := range requests {
  wg.Add(1) // группын тоолуурыг нэмэх

  go func(r *Request) {
      defer wg.Done()  // дууссан болохыг мэдэгдэх, defer хийх

	  reply:=doJob(r) // ажил хийх
	  jobChan<-reply  // хариу илгээх
  }(&req)
}

// бүх go функц дуусахыг хүлээх
wg.Wait()
```
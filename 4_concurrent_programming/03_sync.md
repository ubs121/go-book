# Хандалтыг зохицуулах (Synchronize)

Go функцүүдийн нөөцийн төлөө өрсөлдөөнийг зохицуулах хэд хэдэн арга бий.

## Суваг ашиглан зохицуулах

Нэгдүгээрт суваг ашиглаж болно. Сувгийн зориулалт нь go функцүүдийн хооронд мессеж/өгөгдөл дамжуулах гэдгийг бид мэднэ. Үүнээс өөрөөр мөн go функцүүдийг зохицуулах (синхрончлох) зорилгоор ашиглаж болно.

```go
type Ball struct{ hits int }

// тоглогч функц
func player(name string, table chan *Ball) {
	for {
		ball := <-table // ширээнээс ойсон бөмбөг авах
		ball.hits++     // цохилтын тоог нэмэх (дундын нөөц)
		fmt.Println(name, ball.hits)
		time.Sleep(100 * time.Millisecond)

		// бөмбөгийг ширээ рүү буцаах
		table <- ball
	}
}

func main() {
	// ping-pong ширээнд зориулсан суваг
	table := make(chan *Ball)

	// хоёр тоглогч үүсгэх
	go player("ping", table)
	go player("pong", table)

	// бөмбөгийг шидэж тоглоомыг эхлүүлэх
	table <- new(Ball)

	// хэсэг хугацаанд тоглох боломж олгох
	time.Sleep(2 * time.Second)

	<-table // тоглоом дууслаа; бөмбөгийг барих
}
```

Энэ жишээний `table` суваг нь зөвхөн өгөгдөл (бөмбөг) дамжуулах зорилготой биш, мөн нөөцийн (цохилтын тоо) хандалтыг зохицуулах зорилготой байна.

## Mutex ашиглан зохицуулах

Зарим тохиолдолд зохицуулагч обект ашиглан өгөгдөлд хандалтыг синхрончлох нь оновчтой байдаг. Энэ зорилгоор `sync.Mutex` обектыг ашиглаж болно.

Энэ төрлийн синхрончлолд дундын нөөц рүү тухайн мөчид зөвхөн нэг go функц хандахыг зөвшөөрөх замаар зохицуулалт хийдэг. Хэрэв тэр нэг go функц нь алдаа гаргавал түгжрэх нөхцөл үүсэж болно. Тийм учраас өгөгдлийн бүтэцээ параллел ажиллагаанд зориулан нарийн зохиомжлох хэрэгтэй.

Дараах жишээнд `atomicInt` нэртэй бүхэл тоо үүсгэсэн байна. `mutex` обект ашиглан зохицуулсанаар `atomicInt` хувьсагчид олон go функц хандаж өөрчлөлт хийхэд аюулгүй болж байна.

```go
var atomicInt int // дундын нөөц

var mutex sync.Mutex
mutex.Lock()
atomicInt++ // нөөцөд хандах
mutex.Unlock()
```


## for/select ашиглан зохицуулах

Жишээ болгон тойрог дараалал руу бичих, унших үйдлийг зэрэг гүйцэтгэх producer-consumer загварын функц хэрхэн зохиомжлохыг үзэе. Өгөгдөл `producer` сувгаас орж ирэх бөгөөд дараалал руу заасан байрлалд бичигдэнэ. Нөгөө талаас `consumer` сувгаар дамжин тасралтгүй унших үйлдэл хийгдэнэ. Унших болон бичих үйлдэл нь бие биенээсээ хамааралгүй хийгдэнэ. Дундын нөөц болох `rb` обектод хандалтыг `for/select` хослолоор зохицуулж байна.

```go
func circularQueue[T any](size int, producer chan *T, consumer chan *T) {
	rb := make([]*T, size) // дундын нөөц (ring buffer)
	writeIndex := 0        // бичих байрлал
	readIndex := 0         // унших байрлал

	// нөхцөлгүй үргэлжлэн давтах
	for {
		select {
		case m := <-producer: // 'producer' сувгаас уншихыг оролдох
			if m != nil {
				// тойрогт нэмэх
				rb[writeIndex%size] = m
				writeIndex++
			}
		default:
			//  унших өгөгдөл байхгүй тохиолдолд
			// 'consumer' суваг руу илгээхийг оролдох

			// дараагийн илгээх өгөгдөл
			m := rb[readIndex%size]
			if m != nil {
				consumer <- m // илгээх
				readIndex++

				// завсарлага
				// time.Sleep(100 * time.Millisecond)
			}
		}
	}
}

```
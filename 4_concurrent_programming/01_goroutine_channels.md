##  Go функц (goroutine)

Go функц гэдэг нь бусад функцтэй зэрэгцэн ажиллах функц юм. Go функц үүсгэхийн тулд функцийн нэрний өмнө `go` түлхүүр үгийг тавьж дуудах хэрэгтэй:

```go
package main
import "fmt"

func f(n int) {
    for i := 0; i < n; i++ {
        fmt.Println(n, ":", i)
    }
}

func main() {
    go f(10) // main()-тэй параллел goroutine эхлүүлж байна
    
    var input string
    fmt.Scanln(&input)
}
```

Дээрх програм нь хоёр функцээс тогтоно. Эхнийх нь `main()` функц өөрөө байна, хоёр дахь нь `go f(10)` гэсэн дуудалтаар үүснэ. Ердийн үед функц дуудахад тухайн функц дотор бичигдсэн бүх заавар ажиллаж дууссаны дараа дараагийн мөрд програмын удирдлага шилждэг. Go функцийн тохиолдолд програмын удирдлага шууд дараагийн мөрд шилжинэ, ө.х Go функц дотор бичигдсэн зааврууд ажиллаж дуусахыг хүлээхгүй гэсэн үг. Үүнийг нотлон харуулах зорилгоор `fmt.Scanln()` функцийг дуудсан байгаа. Энэ функц нь гараас мэдээлэл оруулахыг хүлээнэ, хэрэв ингэж хүлээхгүй бол програмын ажиллагаа шууд тасарч `f()` функц тоонуудыг хэвлэж амжихгүй тасрах болно.

Go функц нь маш хөнгөн байдаг бөгөөд олон тоогоор үүсгэх боломжтой байдаг. Жишээлбэл 100 ширхэг go функцийг дараах байдлаар үүсгэж болно:

```go
func main() {
    for i := 0; i < 100; i++ {
        go f(i)
    }
    var input string
    fmt.Scanln(&input)
}
```

Дээрх програмыг ажиллуулахад go функцүүд дарааллаар ажиллаад байгаа мэт харагдаж байгааг ажиглаарай. Ө.х тоонууд дэс дарааллын дагуу хэвлэгдэж байна. Үнэндээ go функцүүдыг дуудсан дарааллаар маш хурдан ажиллаж дуусаад байгаа учраас тэгж харагдаж байгаа юм. Зэрэг ажиллаж байгааг нотлохын тулд тоо хэвлэлтүүдийн хооронд бага зэрэг хүлээлт оруулая. Үүнд `time.Sleep` ба `rand.Intn` функцүүдийг хослуулан ашиглаж болно:

```go
package main

import (
  "fmt"
  "time"
  "math/rand"
)

func f(n int) {
    for i := 0; i < 10; i++ {
        fmt.Println(n, ":", i)
        amt := time.Duration(rand.Intn(250))
        time.Sleep(time.Millisecond * amt)
    }
}

func main() {
    for i := 0; i < 10; i++ {
        go f(i)
    }
    var input string
    fmt.Scanln(&input)
}
```

Өөрчлөлтийн үр дүнд `f()` функц бүр 0 – 10 хүртэлх тоог 0 - 250 миллисекундын завсарлагатайгаар хэвлэнэ. Завсарлага оруулснаар бусад функцүүд зэрэг ажиллаж ижил үйлдлийг хийж байгаа гэдгийг харах боломжтой болсон байна.

## Суваг

Зэрэгцээ ажиллаж байгаа хоёр go функц хоорондоо мэдээлэл солилцохдоо _суваг_ ашиглана. Дараах програмд суваг ашигласан байна:

```go
package main
import (
  "fmt"
  "time"
)

func pinger(c chan string) {
    for i := 0; ; i++ {
        c <- "ping"
    }
}

func printer(c chan string) {
    for {
        msg := <- c
        fmt.Println(msg)
        time.Sleep(time.Second * 1)
    }
}

func main() {
    var c chan string = make(chan string)

    go pinger(c)
    go printer(c)

    var input string
    fmt.Scanln(&input) // Enter дарахыг хүлээх
}
```

Энэ програм “ping” текстийг тасралтгүй хэвлэх болно, зогсоохын тулд Enter товчлуур дарах хэрэгтэй.

Суваг үүсгэхдээ `chan` түлхүүр үгийн араас өгөгдлийн төрлийг зааж бичнэ. Зүүн сум `<-` үйлдэл нь сувгаар өгөгдөл илгээх, сувгаас өгөгдөл хүлээн авахад ашиглагдана. `c <- "ping"` заавар нь "ping" текстийг `c` сувгаар илгээ гэсэн утгатай юм. `msg := <- c` заавар нь `c` сувгаас мессеж уншиж `msg` хувьсагчид хадгал гэсэн утгатай.

Go функцүүдийн хооронд суваг ашигласнаар тэдгээрийн ажиллагааг харилцан дараалалд оруулдаг. Тухайлбал `pinger()` функц сувгаар мессеж илгээх бөгөөд түүнийг `printer()` функц хүлээн авах хүртэл уг цэг дээр ажиллагаа нь зогсох болно. Үүнийг мөн өөрөөр түгжээ гэж хэлдэг.

Өмнөх сувгаар дахиад нэг өгөгдөл илгээдэг go функц нэмж юу болохыг харая:

```go
func ponger(c chan string) {
    for i := 0; ; i++ {
        c <- "pong"
    }
}
```

main функцийг дараах байдлаар өөрчлөнө:

```go
func main() {
    var c chan string = make(chan string)

    go pinger(c)
    go ponger(c)
    go printer(c)

    var input string
    fmt.Scanln(&input)
}
```

Дээрх функцийг нэмсэнээр програм "ping" болон "pong" текстүүдийг тасралтгүй хэвлэх болно.

## Сувгийн чиглэл

Сувагт чиглэл зааж болно, ингэснээр зөвхөн хүлээж авах эсвэл илгээх чиглэлтэй болно. Жишээлбэл `pinger()` функцийг дараах байдлаар зөвхөн илгээгч болгон тодорхойлж болно:

```go
func pinger(c chan<- string)
```

Үүний үр дүнд `c` суваг уруу зөвхөн өгөгдөл илгээж болно, энэ сувгаас өгөгдөл унших гэж оролдвол алдаа болох болно.

Үүнтэй төстэйгээр `printer()` функцийг зөвхөн хүлээн авагч болгон өөрчилж болно:

```go
func printer(c <-chan string)
```

## Буферт суваг

Суваг үүсгэх үед сувгийн багтаамжийг заасан хоёр дахь параметр заах боломжтой:

```go
c := make(chan int, 3)
```

Дээрх заавар нь `3` багтаамжтай суваг үүсгэнэ.

Ердийн суваг нь синхрон байдаг, ө.х сувгийн хоёр талд байгаа илгээгч, хүлээн авагч нь нөгөөгөө бэлэн болтол хүлээдэг. Харин буферт суваг нь асинхрон байдаг; ө.х суваг дүүрэхгүй л бол илгээгч, хүлээн авагчид дээр хүлээлт үүсэхгүй гэсэн үг.


## Select

Сувагтай ажиллахад зориулсан `select` түлхүүр үг байдаг. Энэ функц нь `switch` заавартай төстэй ажилладаг. Өөрөөр хэлбэл олон сувгаас сонгож хариу хүлээн авах эсвэл илгээх юм. 

`select` нь өгөгдөл хүлээн авах боломжтой байгаа сувгийг сонгоно (эсвэл илгээх боломжтой). Хэрэв нэгээс олон сувгаас өгөгдөл унших боломжтой болсон байвал санамсаргүйгээр нэгийг нь сонгоно. Хэрэв ямар ч суваг бэлэн биш байвал бэлэн болтол хүлээнэ.

```go
func main() {
    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        for {
            c1 <- "from 1"
            time.Sleep(time.Second * 2)
        }
    }()

    go func() {
        for {
            c2 <- "from 2"
            time.Sleep(time.Second * 3)
        }
    }()

    go func() {
        for {
            // боломжит сувгуудаас сонгож унших
            select {
            case msg1 := <- c1:
                fmt.Println("Мессеж 1", msg1)
            case msg2 := <- c2:
                fmt.Println("Мессеж 2", msg2)
            default:
                fmt.Println("өгөгдөл бэлэн суваг алга!")
            }
        }
    }()

    var input string
    fmt.Scanln(&input)
}
```

Дээрх програм нь 2 секунд тутамд “from 1” текст, 3 секунд тутамд “from 2” текст хэвлэнэ.
# TCP протоколоор өгөгдөл солилцох

Тухайн нэг компютер, төхөөрөмжийг хаягаар нь яаж олж болохыг бид мэдлээ. Одоо хоёр төхөөрөмжийн хооронд хэрхэн мэдээлэл солилцох тухай үзэе.

Хоёр төхөөрөмжийн (компютерын) аль нэг нь сервер, нөгөө нь клиент байх хэрэгтэй.

## Клиент програм үүсгэх

Хэрэв клиент бол дараах алхамууд хийгдэнэ:

* Серверийн хаяг, портыг зааж хүсэлт илгээнэ, үүнд `net.DialTCP()` функцийг ашиглана;
* Хэрэв холболт амжилттай болвол `TCPConn` обект үүснэ;
* Үүссэн `TCPConn` обектыг ашиглан сервертэй мэдээлэл солилцоно.
* Холболтыг дуусгахын тулд `TCPConn.Close()` функц ашиглана.

Жишээ болгон дурын веб сервер уруу хандаж нэг хуудас татах энгийн клиент програм үүсгэе.  
Вэб серверт илгээж болох хамгийн энгийн мэдээлэл бол "HEAD" мессеж юм. Энэ хүсэлт нь сервер болон сервер дээрх тухайлсан баримтын тухай мэдээлэл авахад хэрэглэгдэнэ. Сервер хүсэлтийн хариуд мэдээлэл илгээх боловч баримтыг өөрийг нь илгээхгүй.

Хүсэлт дараах байдалтай илгээгдэнэ:

```http
"HEAD / HTTP/1.0\r\n\r\n"
```

Хариу нь дараах байдалтай харагдана:

```http
HTTP/1.0 200 OK
ETag: "-9985996"
Last-Modified: Thu, 25 Mar 2010 17:51:10 GMT
Content-Length: 18074
Connection: close
Date: Sat, 28 Aug 2010 00:43:48 GMT
Server: lighttpd/1.4.23
```

Програмаа `GetHeadInfo.go` гэж нэрлээд дараах байдлаар ажиллуулна гэж тооцоё.

```sh
./GetHeadInfo www.google.com:80
```

Програмын бүрэн эх кодыг доор харуулав.

```go
// GetHeadInfo.go
package main

import (
  "fmt"
  "os"
  "io"
  "net"
)

func main() {
  if len(os.Args) != 2 {
    fmt.Fprintf(os.Stderr, "host:port заана уу")
    os.Exit(1)
  }
  // холбогдох гэж байгаа серверийн хаягийг шалгах
  service := os.Args[1]
  tcpAddr, err := net.ResolveTCPAddr("tcp4", service)
  checkError(err)

  // холболт тогтоох
  conn, err := net.DialTCP("tcp", nil, tcpAddr)
  checkError(err)

  // хүсэлт илгээх
  _, err = conn.Write([]byte("HEAD / HTTP/1.0\r\n\r\n"))
  checkError(err)
  
  // хариу мэдээллийг унших
  result, err := io.ReadAll(conn)
  checkError(err)

  // авсан хариуг дэлгэцэнд хэвлэж харуулах
  fmt.Println(string(result))
  os.Exit(0)
}

func checkError(err error) {
  if err != nil {
    fmt.Fprintf(os.Stderr, "Алдаа: %s", err.Error())
    os.Exit(1)
  }
}
```

Дээрх програмд олон тооны алдаа шалгалт байгааг ажиглаарай. Сүлжээний програмд алдаа гарах магадлал өндөр байдаг учраас боломжит бүх нөхцөлийг шалгах хэрэгтэй байдаг. Жишээлбэл клиент, серверийн дунд  ажиллаж байгаа рүүтер, свич зэрэг сүлжээний төхөөрөмж гэмтэж болно, эсвэл галт ханаар холболт хаагдаж болно, эсвэл сүлжээний ачааллаас шалтгаалан дамжуулалтын хугацаа хэтэрч (timeout) болно, эсвэл сервер унах буюу хариу өгөхгүй байх гэх мэт олон асуудлууд байж болно.

Бидний жишээ програмын хувьд дараах нөхцөлүүдийг шалгасан байна:  
1. Серверийн хаяг зөв бичигдсэн эсэх  
2. Сервер уруу холболт амжилттай хийгдсэн эсэх. Жишээлбэл сервер унтарсан байж болно, эсвэл нэрийг нь буруу заасан байж болно  
3. Холболт тогтсоны дараа өгөгдөл солилцох (унших, бичих) явцад холболт тасарч болно, эсвэл дамжуулалтын хугацаа хэтэрч болно

## Сервер програм үүсгэх

Сервер програм үүсгэхийн тулд дараах алхмууд гүйцэтгэнэ:

* Тодорхой порт дээр хүлээх `Listener` обект үүсгэнэ;
* `Accept()` методын тусламжтайгаар клиент холбогдохыг хүлээнэ;
* Клиент холбогдмогц `Accept()` метод уг клиенттэй буцаан холбогдох `Conn` төрлийн обектийг үүсгэж өгнө;
* Энэ буцаасан `Conn` обектоор дамжуулан клиент руу бичилт, уншилт хийнэ;
* Холболтыг дуусгахын тулд `Close()` методоор хаана.

Жишээ болгон цагийн сервер програм үүсгэе.

Энэ сервер нь 1200 порт дээр клиентээс холболт хийхийг хүлээж зогсолтын төлөвт байна.  Сонсох бүтэн хаягийг ":1200" байдалтай бичсэн байна, энэ нь бүх сүлжээ интерфэйс дээр 1200 портоор сонсоно гэсэн үг.

Клиент холбогдох үед түүнтэй мэдээлэл солилцох холболтын обект үүсгээд түүгээр дамжуулан цагийн мэдээллийг хариу болгон бичнэ. Тэгээд холболтыг таслана.

Програмын код:

```go
// DaytimeServer.go
package main

import (
  "fmt"
  "net"
  "os"
  "time"
)

func main() {
  service := ":1200"
  listener, err := net.Listen("tcp", service)
  checkError(err)
  for {
    conn, err := listener.Accept()
    if err != nil {
        continue
    }
    daytime := time.Now().String()
    conn.Write([]byte(daytime))
    conn.Close() // нэг хүсэлтэд хариу өгч дууслаа
  }
}

//  checkError(err error) функцийг энд оруулна
```

Серверийг ажиллуулвал ямар нэг үйлдэл хийлгүй зүгээр хүлээх болно. Хэрэв клиент холбогдвол цагийн мэдээлэл илгээгээд холболтоо хаана, тэгээд дараагийн клиентийг хүлээн зогсох болно.

Энэ сервертэй холбогдох клиент програм бичиж болно. Гэхдээ хамгийн хялбар шалгах арга нь `telnet` эсвэл `nc` програмыг ашиглах явдал юм.

```sh
$ telnet localhost 1200
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
2014-01-05 17:51:06.027684065 +0800 ULAT
Connection closed by foreign host.
```

Энд `2014-01-05 17:51:06.027684065 +0800 ULAT` хэсэг нь серверээс ирсэн хариу байна.

`nc` команд ашиглавал:

```sh
$ nc localhost 1200
2014-01-05 18:29:57.579271708 +0800 ULAT
```

## Олон хүсэлтийг зэрэг боловсруулах

Дээрх програм нь нэг агшинд зөвхөн нэг клиентэд хариу өгөх боломжтой сервер юм. Хэрэв олон клиентээс нэгэн зэрэг хүсэлт ирвэл тэдгээрт нэг нэгээр нь дараалан хариу өгнө, бусад нь түр хүлээх хэрэгтэй болно. Бодит практикт энэ нь тохирохгүй шийдэл юм, веб сервер нэгэн зэрэг маш олон хүсэлтэд хариу үзүүлэх чадвартай байх хэрэгтэй. Үүнийг шийдэхийн тулд go функц ашиглан хүсэлтийг параллел боловсруулах хэрэгтэй болно.

Жишээ болгон клиентээс ирсэн мэдээллийг тэр хэвээр нь буцаан хариу болгон илгээдэг `Echo` нэртэй сервер үүсгэе.

```go
// Echo.go
package main

import (
  "fmt"
  "net"
  "os"
)

func main() {
  service := ":1201"
  listener, err := net.Listen("tcp", service)
  checkError(err)
  for {
      conn, err := listener.Accept()
    if err != nil {
      continue
    }
    // параллел боловсруулах
    go handleClient(conn)
  }
}

func handleClient(conn net.Conn) {
  defer conn.Close()
  var buf [512]byte
  for {
    n, err := conn.Read(buf[0:])
    if err != nil {
      return
    }

    // уншсан өгөгдлөө буцаан бичих
    if _, err2 := conn.Write(buf[0:n]); err2 != nil {
      return
    }
  }
}

//  checkError(err error) функцийг энд оруулна
```

## Холболтыг удирдах

Клиентээс тодорхой хугацаанд багтааж хүсэлтээ илгээхгүй бол сервер талын санаачлагаар холболтыг тасалж болно. Мөн эсрэгээр серверээс тодорхой хугацаанд багтаан хариу өгөхгүй бол клиент талын санаачлагаар холболтыг тасалж болно. Үүнийг `SetTimeout` функцээр шийднэ.

```go
func (c *TCPConn) SetTimeout(nsec int64) os.Error
```

Клиент, серверийн холболтыг "амьд" байлгах шаардлага гарч болно. Үүнд дараах функцийг ашиглаж болно.

```go
func (c *TCPConn) SetKeepAlive(keepalive bool) os.Error
```

Энэ хоёр функцээс гадна холболтыг удирдах өөр олон функцүүд `net` санд байгаа.


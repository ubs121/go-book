# Бүтэц

Агуулахын бүртгэлд зориулсан програм бичиж байна гэж бодоё. Агуулах нь төрөл бүрийн бараатай хайрцагаар дүүрсэн. Хайрцаг бүрийн хувьд дараах зүйлсийг бүртгэх хэрэгтэй:

* Агуулж байгаа барааны нэр
* Тоо ширхэг
* Үнэ

Эндээс нэг хайрцагийн тухай мэдээллийг програмд хэрхэн хадгалах вэ гэсэн асуулт гарна. Тухайлбал барааны нэр, тоо ширхэг, үнэ зэрэг өөр өөр төрөлтэй мэдээллүүдийг "нэг багц" болгон бүртгэх хэрэгтэй байна. Энэ тохиолдолд шинэ төрөл үүсгэх нь тохиромжтой юм.

`struct` түлхүүр үг нь шинэ, нийлмэл өгөгдлийн төрөл үүсгэхэд ашиглагдана. Мөн өөрөөр _бүтэц төрөл_ гэж нэрлэдэг. Нийлмэл төрөл дотор бичигдсэн гишүүн хувьсагчийг _талбар_ гэнэ.

Жишээлбэл:

```go
type Box struct {
  name    string        /* барааны нэр */
  quantity    int        /* тоо ширхэг */
  cost    float64        /* нэг бүрийн үнэ */
}
```

`type` түлхүүр үг нь шинэ төрөл үүсгэж байгааг илэрхийлнэ. Түүний араас төрлийн нэр, тэгээд `struct` түлхүүр үгийг залгаж бичнэ.

## Шинэ обект үүсгэх

Шинэ төрлөөс обект үүсгэх хэд хэдэн арга зам бий:

```go
var b Box

// эсвэл дараах байдлаар үүсгэж болно
// new() ашигласан үед заагч үүснэ
b := new(Box)
```

Бусад энгийн төрөлтэй адилаар `Box` төрлийн талбарууд нь (гишүүд) өөрсдийн төрлөөс хамааран `null` эсвэл `0` утгатай үүснэ. Үүнийг өөрчилж тодорхой утгууд заахыг хүсвэл дараах байдлаар бичнэ:

```go
b := Box { name: "Алим", quantity: 100, cost: 500.0 }

// эсвэл товчлоод талбарын нэрсийг орхиж болно
b := Box {"Алим", 100, 500.0}
```

## Талбарт хандах

Нийлмэл төрлийн талбарт хандахдаа цэг `.` үйлдлийг ашиглана:

```go
b.quantity = 10
b.cost = 510

println(b.name, b.quantity, b.cost)
```

## Метод

Хайрцагийн нийт өртөгийг тооцоолох функцийг дараах байдалтай бичиж болно:

```go
func boxPrice(b Box) float64 {
    return b.quantity * b.cost
}
```

Эсвэл `boxPrice()` функцийг дараах байдлаар бүтцийн гишүүн болгон өөрчилж болно.  Ийм функцийг _метод_ гэж нэрлэнэ.

```go
func (b Box) Price() float64 {
    return b.quantity * b.cost
}
```

Методын бичиглэл нь ердийн функцээс бага зэрэг ялгаатай. Функцийн нэрний өмнө харъяалах обектыг заах хэрэгтэй. Энэ обектыг _хүлээн авагч_ гэж нэрлэнэ. Дээрх жишээнд `b` нь хүлээн авагч юм. 

Анхны `boxPrice()` функцийн нэрийг товчлоод `Price()` болгосон. Энэ функц одоо `Box` төрөлд хамаатай болсон учраас "box" угтвар шаардлагагүй болж байна. Метод ашиглах нь нэр товчлохоос гадна кодыг илүү ойлгомжтой болгож өгдөг.

Ингээд методыг дуудахдаа талбарт хандахтай адилаар цэг `.` үйлдэл хэрэглэнэ:

```go
println(b.Price())
```

Хэрэв өгөгдөл дээр өөрчлөлт хийдэг метод толорхойлох бол хүлээн авагчийг заагч болгон өөрчлөх хэрэгтэй. Энэ нь тухайн метод хүлээн авагчийн зааж байгаа эх өгөгдөл дээр ажиллана гэсэн үг.

```go
func (b *Box) ChangeCost(delta float64)  {
    if b != nil {
        b.cost = b.cost + delta
    }
}
```

# Төрөл өртгөтгөх

Бүтцийн талбарууд нь ихэвчлэн "юмтай байх", "агуулагдах", "харяалагдах" хамаарлыг илэрхийлдэг. Жишээлбэл дараах `Person` төрөл `Name` талбартай байна. Эндээс "хүн бол нэртэй" гэсэн хамаарал харагдаж байна.

```go
type Person struct {
    Name string
}
```

Харин методууд нь тухайн төрлийн "чадвар", "зан байдлыг" илэрхийлдэг. Жишээлбэл `Person` төрөлд `Talk()` функц нэмэе. Эндээс "хүн ярьж чаддаг" гэсэн чадвар харагдах болно.

```go
func (p *Person) Talk() {
    println("Сайна уу, Миний нэр ", p.Name)
}
```

Дээрх төрлийг өргөтгөж `Android` нэртэй шинэ төрөл үүсгэе. Ингэхдээ шинэ `Android` төрөл нь `Person`-д байгаа бүх шинжийг авахыг хүсвэл яах вэ?  Үүнийг "Android бол Person" хэлбэрийн хамаарал гэж хэлж болно, ө.х `Person`-д байдаг шинжүүд (талбарууд) болон чадваруудыг (метод) бүгдийг нь `Android` агуулна гэсэн үг.

Ийм маягийн хамаарлыг бусад програмчлалын хэлэнд удамших, өвлөх, өргөтгөх гэх мэтээр нэрлэдэг. Go хэлэнд _эмбеддэд төрөл_ гэж нэрлэдэг бөгөөд дараах байдлаар бичдэг.

```go
type Android struct {
    Person     // embedding буюу өргөтгөх

    model string // шинэ гишүүн
}
```

Энд `Person` төрлийн урд обект байхгүй бичигдсэнийг анзаараарай. Энэ тодорхойлолт нь шинээр үүсэж байгаа `Android` төрөл нь `Person` төрлийн бүх шинж, чадварыг агуулна гэдгийг илэрхийлнэ.

Ингээд хэрэв `Android` бол `Person` гэдэг нь үнэн бол `Android` төрлийн обект мөн "ярьж чадах" ёстой:

```go
a := new(Android)
a.Talk()
```

`Android` төрөлд `model` нэртэй нэг шинэ талбар нэмэгдсэн байгааг анзаараарай. Эндээс "Android бол Person" гэдэг нь үнэн, харин `Person` нь `Android`-оос өөр болж байна.
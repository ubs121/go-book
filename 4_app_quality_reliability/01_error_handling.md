# Алдааны төрлүүд

Програмд төрөл бүрийн алдаа гарч байдаг. Програм нь логикын хувьд бүрэн зөв хийгдсэн ч гадаад хүчин зүйлээс хамааран алдаа гарах эрсдэл байсаар байдаг. Эдгээрийг рантайм алдаа, файл системийн алдаа, өгөгдлийн сангийн алдаа, сүлжээ, холболтын алдаа гэж ангилж болох юм.

_Рантайм алдаа_ гэдэг нь програм ажиллаж байх үед гарч байгаа алдааг хэлнэ. Рантайм алдаа гарсан үед програмын ажиллагаа шууд зогсдог. Тиймээс рантайм алдааг олох, засахад харьцангуй хялбар байдаг. Гэхдээ бодит хэрэглээнд нэвтэрсэн програмд рантайм алдаа нь ихээхэн хор уршигтай байдаг.

Зарим рантайм алдааг дурдвал:

* _Segmentation Violation_. Програм зөвршөөрөлгүй санах ойн мужид (буруу хаягтай заагчаар дамжуулан) хандалт хийхийг оролдох үед үүснэ.
* _Stack Overflow_. Програмд хэтэрхий олон тооны локаль хувьсагчид ашигласан үед энэ алдаа гарна. Ихэвчлэн маш том массивыг локаль байдлаар зарлах, эсвэл төгсгөлгүй рекурсив дуудалтын үед тохиолддог.
* _Divide by Zero_. Тоог 0-д хуваах алдаа.

Рантайм алдаатай жишээ програм үзэе.

```go
package main

func main() {
    i:=1; j:=0;
    println("Хуваахын өмнө...");
    i = i / j;  /* 0-д хуваах алдаа */
    println("Дараа нь")
}
```

Энэ програмыг ажиллуулахад "Divide by Zero" рантайм алдаа гарна. Ө.х `i = i / j` заавар дээр `j=0` байх учраас рантайм алдаа гарч програм тасрана.

```sh
$ go run runtime_error.go
Хуваахын өмнө...
panic: runtime error: integer divide by zero
[signal 0x8 code=0x1 addr=0x400c5d pc=0x400c5d]

goroutine 1 [running]:
runtime.panic(0x421520, 0x4572bd)
    /go/src/pkg/runtime/panic.c:266 +0xb6
main.main()
    /go-book/src/runtime_error.go:6 +0x5d
exit status 2
```

_Файл системийн алдаа_ нь байхгүй эсвэл зөвшөөрөгдөөгүй файлд програм хандах, бичихийг оролдох үед үүсдэг.

_Өгөгдлийн сангийн алдаа_:  өгөгдлийн серверээс холболт тасрах, нэвтрэх эрх буруу, өгөгдөлтэй ажиллах команд буруу, өгөгдлийн уялдаа алдагдах, өгөгдөл давхардах зэрэг багтана.

_Сүлжээний алдаа_: сүлжээний холболт тасрахад төгсгөлийн цэгүүд дээр ажиллаж байгаа програмуудад харилцан адилгүй нөлөөлж байдаг. Жишээ нь клиент талаас санаачлан холболтыг хүчээр таслахад клиент дээр алдаа гарахгүй боловч сервер талын програмд урьдчилан тооцоогүй нөхцөл байдал үүсэж болно. Тиймээс сүлжээний орчны програмын алдааг шинжлэхэд нэлээд төвөгтэй байдаг.

_Үйлдлийн системийн алдаа_: үйлдлийн системийн санах ой, CPU, дискийн багтаамж зэрэг нөөц хүрэлцэхгүй байх тохиолдлуудыг хэлнэ. Үйлдлийн системийн алдаа гарсан үед түүнээс үүдээд олон дагавар алдаанууд гарч байдаг.

# Алдааг боловсруулах

Алдааг ихэвчлэн функцийн буцах утгаар мэдээлдэг. Тиймээс функцээс буцааж байгаа алдааны утгыг байнга шалгаж байх хэрэгтэй.

```go
if value, err := pack1.Func1(param1); err != nil {
  fmt.Printf("Алдаа %s", err.Error())
  return err
}
// алдаагүй бол value-г ашиглан дараагийн үйлдлийг гүйцэтгэнэ
```

Алдааг `error` интерфэйс төрлөөр тодорхойлдог. Энэ нь ямар нэг хэвийн бус төлөв үүссэн болохыг илэрхийлнэ. Алдааны утга `nil` бол алдаа гараагүй гэж үзнэ.

Алдаа боловсруулалтад анхаарах хэдэн зүйл бий:

* функцээс буцаасан алдааны кодыг байнга шалгах
* алдааг хэрэглэгчид мэдээлэх
* алдааг бичиж тэмдэглэж авах (лог файлд, өгөгдлийн санд)

Go хэлэнд try/catch механизм байхгүй. Харин defer, panic, recover зэрэг алдаа боловсруулах боломжууд бий. `defer`, `panic`, `recover` заавруудыг хослуулан хэрэглэж try/catch механизмтай ижил үр дүнд хүрэх боломжтой.

## Defer

`defer` заавар нь функцийн дуудалтыг стайкт бүртгэнэ, ингээд  функцийн ажиллагаа дуусахад төгсгөлд `defer`-т сануулсан функц, кодыг ажиллуулдаг. Функц алдаатай эсвэл хэвийн дууссан аль ч тохиолдолд `defer`-д бүртгүүлсэн дуудалт заавал ажилладаг. Тиймээс `defer` нь төгсгөлийн "цэвэрлэгээний" ажилд ихэвчлэн хэрэглэгддэг.

Жишээлбэл файл нээсэн бол заавал хаах хэрэгтэй байдаг. Хаах үйлдлийг функцийн эхэнд `defer` заавраар сануулаад орхиж болно. Функц дуусахад `defer` нь файлыг найдвартай хаах болно.

```go
func FileProcessing() {
  file, err := os.Open( "file.txt" )

  defer file.Close() // сануулж орхих, энэ код төгсгөлд нь ажиллана

  // … бусад үйлдэл
}
```

## Panic

Функц дотор `panic()` дуудвал ажиллагаа нь зогсож дээд функц рүү удирдлага шилжинэ. Хэрэв өмнө нь `defer` дуудалт байсан бол удирдлага шилжихээс өмнө түүнийг ажиллуулна. Энэ процесс дээш үргэлжлэн шилжсээр `main` функц дээр очиж програмын ажиллагааг таслан дэлгэцэнд алдааны мэдээлэл хэвлэж дуусдаг.

```go
var user = os.Getenv("USER")
func check() {
  if user == "" {
     panic("$USER өгөгдөл олдсонгүй")
  }
}
```

`regexp.MustCompile`, `template.Must` гэх мэт стандарт сангийн олон функц panic үүсгэдэг. Мэдээж panic үүсгэж програмыг таслах нь хүсэхээр зүйл биш юм. Тиймээс аль болох ийм нөхцөл үүсэхээс зайлсхийж хамгаалах шалгалтууд хийх ёстой.

## Recover

`panic`-н гинжин дуудалтыг зогсооход `recover` зааврыг ашиглаж болно. `recover` нь panic-д орсон цуваа дуудалтыг зогсоон удирдлагыг авч функцийн ажиллагааг хэвийн үргэлжлүүлэх боломжийг олгоно.

`recover` зааврыг `defer` хийсэн функц дотор ашиглах хэрэгтэй. Ингэснээр функцийн төгсгөлд алдааг барьж цааш дамжуулалгүй шийдэх боломжтой болно.

Тэгэхээр `panic`-н тодорхойлолтыг бага зэрэг засвал: `panic` нь програмын ажиллагааг зогстол эсвэл замд нь `recover` заавар таарах хүртэл үргэлжлэн дамждаг гэж тодорхойлж болно.

Дараах жишээнд параметр болгон дамжуулсан `g` функцээс үүсэж болох алдааг `defer` дотор `recover` заавраар хамгаалсан байна.

```go
func protect(g func()) {
 defer func() {
   // panic-г барьж мэдээлэх
   if r := recover(); r != nil {
    log.Printf("panic мэдээлэл: %v", r)
   }
 }()

 log.Println("эхлэл")

 g()
 // рантайм алдаа гарч болзошгүй хэсэг
}
```

Бүх алдааг `recover` заавраар таслаж барих нь буруу байдаг. Ямар нөхцөлд ямар алдааг цааш дамжуулалгүй зогсоох ёстой вэ гэдэг дээр бодох хэрэгтэй. Ерөнхийдөө дараах тохиолдлуудад recover хийх нь зохимжтой:

* сэргээлт хийх
* цэвэрлэгээ хийх
* таслах ёсгүй код

Тухайлбал вэб сервер олон хүсэлттэй зэрэг ажиллаж байдаг. Нэг хүсэлтийг боловсруулах явцад тасалдал үүсэхэд вэб сервер тэр чигээрээ унаж болохгүй. Энэ тохиолдол нь тасалж болохгүй нөхцөл бөгөөд `recover` ашиглах нь зөв байна.

Java, .NET хөгжүүлэгчид `try/catch` блокыг маш их ашигладаг. Гэхдээ ихэнхидээ зориулалтын бусаар ашигладаг. Зарим кодон дотор `catch` блок нь хоосон эсвэл зүгээр л дэлгэцэнд мэдээлэл хэвлэх зорилготой бичигдсэн байдаг. Зөвхөн лог бичиж авах эсвэл "харанхуйгаар" бүх алдааг барьж хорих нь буруу. 

Алдааг барьж хорих, таслахаас илүүтэй цааш дамжуулах тал дээр илүү "ардчилсан" байх хэрэгтэй. Зөвхөн товлосон алдаагаа л барих хэрэгтэй, бусад алдааны хувьд цааш дамжих боломжийг нь олгох хэрэгтэй. Ийм програм нь илүү эрүүл байдаг. Хэрэв алдааг харанхуйгаар таслан зогсоогоод байвал програм гаднаа хэвийн ажиллаж байгаа мэт харагдавч дотроо олон алдаа баагтай, цаашлаад дебааг хийхэд маш хэцүү "дүлий" програм болдог.
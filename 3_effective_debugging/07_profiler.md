# Профайлдах

Ачааллын тестийн дүнд програм ачаалал даах чадваргүй нь тогтоогдож болно. Ийм програмын хувьд цааш нь илүү нарийн шинжилгээ хийх шаардлагатай болдог. Ө.х ямар функц, ямар кодын мөр дээр илүү их хугацаа эсвэл санах ой зарцуулаад байгааг харах хэрэгтэй болно.

Програмын динамик шинж буюу ажиллаж байх үеийн шинж чанарыг нарийвчлан шинжлэх үйлдлийг профайлдах гэж хэлдэг.

"Хэмжиж чадахгүй бол сайжруулж чадахгүй" гэж нэг үг байдаг. Үнэхээр хэмжилтийн чухал багажуудыг мэдэхгүй, эзэмшихгүйгээр сайн програм зохиох, сайн програм зохиогч байх боломжгүй юм.

Програм профайлдахад зориулсан хэд хэдэн багаж бий. CPU хугацаа хянах, санах ойн зарцуулалт хянах, блок илрүүлэх, GC хугацаа хянах, go функц тоолох гэх мэт төрөл бүрийн зориулалттай профайлерууд бий. Эдгээр багаж нь програмын "халуун цэгийг" олж тогтооход чухал үүрэгтэй байдаг.

Эдгээрээс хамгийн өргөн хэрэглэгддэг CPU болон санах ойн профайлеруудын тухай үзэе.

## CPU профайлер

CPU профайлер нь ямар функц ямар хэмжээгээр CPU ашиглаж байгааг харуулдаг.

CPU профайлерыг хэрэглэх олон арга бий. Эхний арга нь өмнө бичсэн ачааллын тест дээр үндэслэн профайлдах юм.  

Үүний тулд профайлдах програм дотроо шинэ флаг оруулах хэрэгтэй, тухайлбал `cpuprofile` нэртэй флаг дараах байдлаар нэмж болно.

```go
var cpuprofile = flag.String("cpuprofile", "", "CPU профайлыг файл руу бичих")

func main() {
    flag.Parse()
    if *cpuprofile != "" {
        f, err := os.Create(*cpuprofile)
        if err != nil {
            log.Fatal(err)
        }
        pprof.StartCPUProfile(f)
        defer pprof.StopCPUProfile()
    }
    
    // ... бусад код
}
```

Энэ нэмэлт код нь CPU профайлер ажиллуулах ба үр дүнг нь `-cpuprofiler` флагт дамжуулсан файл руу хадгална.

Үүний дараа програмаа ажиллуулахдаа `-cpuprofile=<файлын нэр.prof>` тохиргоог нэмэх хэрэгтэй.


```sh
$ go run myprogram.go -cpuprofile myprogram.prof
```

Дараа нь `go tool pprof` командаар үр дүнг текст, вэб, жагсаалт хэлбэрээр харж болно. Эдгээрт харгалзах `–text`, `--web`, `--list` тохиргоонууд бий.

```sh
$ go tool pprof --text .\myprogram.go .\myprogram.prof
```

```sh
Type: cpu
Time: Dec 30, 2023 at 4:24pm (EST)
Duration: 10s, Total samples = 110ms ( 1.10%)
Showing nodes accounting for 110ms, 100% of 110ms total
      flat  flat%   sum%        cum   cum%
     100ms 90.91% 90.91%      100ms 90.91%  main.cpuIntensiveTask
      10ms  9.09%   100%       10ms  9.09%  runtime.memclrNoHeapPointers
         0     0%   100%       10ms  9.09%  runtime.makeslice
         0     0%   100%       10ms  9.09%  runtime.mallocgc
         0     0%   100%       10ms  9.09%  runtime/pprof.(*profMap).lookup
         0     0%   100%       10ms  9.09%  runtime/pprof.(*profileBuilder).addCPUData
         0     0%   100%       10ms  9.09%  runtime/pprof.profileWriter
```

Энэ профайл нь програмын ажиллагаанаас 110ms турш дээж авсан бөгөөд  үүнээс 90.91% нь `main.cpuIntensiveTask` функцийн дуудалт байгаа нь харагдаж байна. Дараа нь 9.09% дуудалттай `runtime.memclrNoHeapPointers` функц байна.

## Санах ойн профайлер

Санах ойн профайлер нь ямар функц ямар хэмжээтэй санах ой ашиглаж байгааг харуулна.

CPU профайлертай төстэй `-memprofile` флаг нэмж ажиллуулах эсвэл /debug/pprof/heap хаягыг нэмж дуудах замаар санах ой ашиглалтыг харж болно.

```go
var memprofile = flag.String("memprofile", "", "Санах ойн профайлыг файл руу бичих")

func main() {
    flag.Parse()
    if *memprofile != "" {
        f, err := os.Create(*memprofile)
        if err != nil {
            log.Fatal(err)
        }
        pprof.WriteHeapProfile(f)
        f.Close()
        return
    }
    
    // ... бусад код
}
```

Ингээд `go tool pprof` багажийг ашиглан яг адил аргаар үр дүнг харж болно.

Санах ойн яг одоогийн ашиглалтыг харах (`--inuse_space` флаг), эсвэл програм эхэлсэн цагаас хойших ашиглалтыг харах (`--alloc_space` флаг) сонголт бий. Эхнийх нь удаан ажиллах програмд тохиромжтой, дараагийнх нь хурдан дуусдаг буюу програмын төгсгөлд профайл харах үед хэрэгтэй.

Санах ойн профайлер нь жинхэнэ бодит зарцуулалтыг харуулахгүй болохыг анхаараарай. Зарим санах ойн хэсгийг жишээ болгон сонгож хэмжээд уг хэмжээнээс харьцангуй тооцож санах ойн зарцуулалтыг харуулдаг. Гэхдээ энэ үр дүн нь бодит хэмжээтэй пропорционал хамааралтай юм. Харьцааг өөрчлөх бол `--memprofilerate` флагийг ашиглах эсвэл `runtime.MemProfileRate` хувьсагчид заах боломжтой. Хэрэв энэ харьцааг `1` гэж заавал бүх санах ойн зарцуулалтыг бодит хэмжээгээр авахыг оролдоно, гэхдээ энэ нь програмын ажиллагааг ихээхэн удаашруулах болно.

Санах ойн зарцуулалтын хэмжээнээс гадна үүссэн обектын тоо, үүссэн байтын тоог харах боломжтой (`--inuse/alloc_space`, `--inuse/alloc_objects` флагууд). Санах ойн профайлер нь аль болох том хэмжээтэй обектуудыг жишээ болгон сонгодог. Гэхдээ том обект санах ой болон `GC` (Garbage Collection) хугацаанд нөлөөлдөг бол бага хэмжээтэй олон обект хурданд илүү сөрөг нөлөөтэй байдаг (мөн тодорхой хэмжээгээр `GC` хугацаанд нөлөөлнө). Тиймээс бага, том хоёуланд нь анхаарлаа хандуулах хэрэгтэй байдаг.

Том обектыг програмын эхэнд үүсгэж ашиглавал програмын хурдад онцын нөлөө үзүүлэхгүй боловч санах ойн профайлерт хамгийн эхэнд өртөнө (том хэмжээтэй учраас). Нөгөө талаас богино хугацаатай олон тооны обект үүсгэвэл профайлерт өртөх нь бага (`--inuse/alloc_objects` ашиглаагүй бол) боловч програмын хурдад илүү нөлөөлнө. Учир нь олон удаа санах ой хувиарлах, чөлөөлөх үйлдэл хийгдэнэ гэсэн үг.

Ерөнхийдөө санах ой хэмнэхэд анхаарч байгаа бол `alloc_space` флаг, програмын хурданд анхаарч байгаа бол `alloc_objects` флагийг ашиглах хэрэгтэй.